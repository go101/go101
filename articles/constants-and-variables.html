<h1>Constants And Variables</h1>

<p>
This article will introduce constant and variable declarations in Go.
The concept of untyped values and explict conversions will also be introduced.
</p>

<p class="anchor" id="untyped-value"></p>
<h3>Untyped Values And Typed Values</h3>

<p>
In Go, some values are untyped.
An untyped value means the type of the value has not been confirmed yet.
On the contrary, the type of a typed value is determined.
</p>

<p>
For most untyped values, each of them has one default type.
The predeclared <code>nil</code> is the only untyped value
which has not a default type.
We can learn more about <code>nil</code> in other Go 101 articles later.
</p>

<p>
The basic value literals (also called literal constants) introduced in
the last article (<a href="basic-types-and-value-literals.html">basic types
and their value literals</a>) are all untyped values.
In fact, in Go,
most untyped values are literal constants and the to be introduced
untyped named constants. The other untyped values include the just mentioned
<code>nil</code> and some boolean results returned by some operations
which will be introduced in other articles later.
</p>

<div>
The default type of a literal constant is determined by its literal form.
<ul>
<li>
	The default type of string literal is <code>string</code>.
</li>
<li>
	The default type of a boolean literal is <code>bool</code>.
</li>
<li>
	The default type of integer literal is <code>int</code>.
</li>
<li>
	The default type of rune literal is <code>rune</code> (a.k.a, <code>int32</code>).
</li>
<li>
	The default type of a floating-point literal is <code>float64</code>.
</li>
<li>
	If a literal contains an imaginary part,
	then its default type is <code>complex128</code>.
</li>
</ul>

<p>
</p>

</div>



<p class="anchor" id="explicit-conversion"></p>
<h3>Explicit Conversions Of Constants</h3>

<p>
Like many other languages, Go also supports value conversions.
We can use the form <code>T(v)</code> to convert a value <code>v</code>
to the type denoted by <code>T</code>
(or simplily speaking, type <code>T</code>).
Surely, for a certain type <code>T</code>,
to make the conversion <code>T(v)</code> legal,
the value <code>v</code> can't be arbitrary.
If the conversion <code>T(v)</code> is legal,
Go compilers view <code>T(v)</code> as a typed value of type <code>T</code>.
</p>

<p>
The next section will introduce named constants.
The basic value literals introudced in the last article is
called literal constants, or unnamed constants.
We will learn that each named constant also denote a literal constant
in the next section.
A constant in Go must be a boolean, numeric or string value.
</p>

<div>
For a constant value <Code>v</code>,
there are two senarios where <code>T(v)</code> is legal.
<ol>
<li>
	<code>v</code> (or the literal denoted by <code>v</code>) is
	<a href="basic-types-and-value-literals.html#representability">representable</a>
	as a value of a basic type <code>T</code>.
	The result value is a typed constant of type <code>T</code>.
</li>
<li>
	The default type of <code>v</code>is an integer type
	and <code>T</code> is a string type.
	The result of <code>T(v)</code> is a string of type <code>T</code>
	and contains the UTF-8 representation of the integer.
	Integer values outside the range of valid Unicode code points
	result a string represented by <code>"\uFFFD"</code>
	(a.k.a., <code>"\xef\xbf\xbd"</code>).
	<code>0xFFFD</code> is the code point for the Unicode replacement character.
	Note, in fact,
	the second senario doesn't require <code>v</code> must be a constant.
	If <code>v</code> is a constant, then the result is also a constant,
	otherwise, the result is not a constant.
</li>
</ol>

For example, the following conversions are all legal.
<pre><code class="language-go">complex128(1 + -1e-1000i)  // 1.0+0.0i of type complex128. Rounding happens here.
float32(0.49999999)        // 0.5 of type float32. Rounding happens here.
float32(17000000000000000) // rounding happens here.
float32(123)
uint(1.0)
int8(-123)
int16(6+0i)
complex128(789)

string(65)          // "A"
string('A')         // "A"
string('\u68ee')    // "森"
string(-1)          // "\uFFFD"
string(0xFFFD)      // "\uFFFD"
string(0x2FFFFFFFF) // "\uFFFD"
</code></pre>

<p>
</p>

And the following conversions are all illegal.
<pre><code class="language-go">int(1.23)        // 1.23 is not representable as a value of int.
uint8(-1)        // -1 is not representable as a value of uint8.
float64(1+2i)    // 1+2i is not representable as a value of float64.

float64(-1e1000)         // constant -1e+1000 overflows float64.
int(0x10000000000000000) // constant 0x10000000000000000 overflows int.

string(65.0)  // the default type of 65.0 is float64 (not an integer type).
string(66+0i) // the default type of 66+0i is complex128 (not an integer type).
</code></pre>

<p>
From the examples, we know that a basic value literal,
for example, <code>-1e1000</code> and <code>0x10000000000000000</code>,
may even not be able to represent as a value of its default type.
</p>

<p>
Please note,
sometimes, the form of explicit conversions must
be written as <code>(T)(v)</code> to avoid ambiguities.
For example, <code>T</code> is an unnamed pointer type.
We can learn more about pointers in the article
<a href="pointer.html">pointers in Go</a> later.
<p>

</div>

<p class="anchor" id="type-deduce"></p>
<h3>Introduction Of Type Deductions In Go</h3>

<p>
Go supports type deduction. In other words, in many circumstances, programmers
don't need to explicitly speficify the types of some values in code.
Go compilers will deduce the types for these values by context.
</p>

<p>
In Go code, if a place needs a value of a certain type and an untyped value
(often a constant) is representable as a value of the certain type,
then the untyped value can be used in the place.
Go compilers will view the untyped value as a typed value of the certain type.
Such places include an operand in an operator operation, an argument in
a function call, a destination value or a source value in an assignment, etc.
</p>

<p>
Some circumstances have no requirements on the types of the used values.
If an untyped value is used in such a circumstance, Go compilers will
treat the untyped value as a typed value of its default type.
</p>

<p>
The two type deduction cases can be viewed as implicit conversions.
Please note that, there is no the implicit conversion concept
in Go specification. This concept is only used in Go 101.
</p>

<p>
The below constant and variable declaration sections
will show some type deduction cases.
More type deduction rules and cases will be introduced in other articles.
</p>

<p class="anchor" id="constant"></p>
<h3>Constant Declarations</h3>

<div>
<p>
The literals introduced in <a href="basic-types-and-value-literals.html">the
last article</a> are all called unnamed constants,
except <code>false</code> and <code>true</code>,
which are two predeclared (built-in) named constants.
This section will introduce how to declare custom named constants.
</p>

Like unnamed constants, named constants can also only be
boolean, numeric and string values.
The keyword <code>const</code> is used to declare named constants.
The following program contains some constant declarations.

<pre class="line-numbers"><code class="language-go">package main

// Declare a single constant.
// Yes, non-ASCII letters can be used in identifiers.
const π = 3.1416
const Pi = π // equivalent to: Pi == 3.1416

// Declare multiple constants as a group by using ().
const (
	No         = !Yes
	Yes        = true
	MaxDegrees = 360
	Unit       = "radian"
)

func main() {
	// Declare multiple constants in one code line.
	const DoublePi, HalfPi, Unit2 = π * 2, π * 0.5, "degree"
}
</code></pre>

<p>
Go specification calls each of the lines containing a <code>=</code> symbol in
the above constant declaration group as a <b><i>constant specification</i></b>.
In the following part of this section,
each constant specification will be called a <b><i>logic code line</i></b>.
</p>

<p>
In the above example,
the <code>*</code> symbol is the multiplication operator
and the <code>!</code> symbol is the boolean-not operator.
Operators will be introduced in the next article,
<a href="operators.html">common operators</a>.
</p>

<p>
The <code>=</code> symbol means "assign".
So each logic code line in a constant declaration
can be viewed as an assignment.
However, more strictly speaking, we should interpret each logic code line
as a declared identifier is bound to a corresponding basic value literal.
Please read the last section in the current article for more explanations.
</p>

<p>
In the above example, the name constants <code>π</code> and <code>Pi</code>
are both bound to the literal <code>3.1416</code>.
The two named constants may be used at many places in code.
Without constant declarations, the literal <code>3.1416</code> would be
populated at those places. If we want to change the literal
to <code>3.14</code> later, many places need to be modified.
With the help of constant declarations, the literal <code>3.1416</code>
will only appear in one constant declaration,
so only one place needs to be modified.
This is the main purpose of constant declarations.
</p>

<p>
Later, we use the terminology <b><i>non-constant</i></b> values
to denote the values who are not constants.
The to be introduced variables below
all belong to one kind of non-constant values.
</p>

<p>
Please note that, constants can be declared both
at package level (out of any function body) and in function bodies.
The constants declared in function bodies are called local constants.
The variables declared out of any function body
are called package-level constants.
We also often call package-level constants as global constants.
</p>

<p>
The declaration orders of two package-level constants are not important.
In the above example, the declaration orders of
<code>No</code> and <Code>Yes</code> can be exchanged.
</p>

<p>
All constants declared in the last example are untyped.
The default type of a named untyped constant is
the same as the literal it denotes.
</p>

</div>

<h4>Typed Named Constants</h4>

<div>

We can delcared typed constants. Typed constants are all named.
In the following example, all the four declared constants are typed values.
The types of <code>X</code> and <code>Y</code> are both <code>float32</code>
and the types of <code>A</code> and <code>B</code> are both <code>int64</code>.

<pre class="line-numbers"><code class="language-go">const X float32 = 3.14

const (
	A, B int64   = -3, 5
	Y    float32 = 2.718
)
</code></pre>

<p>
If multiple typed constants are declared in the same one logic code line,
then their types must be the same, just as the constants
<code>A</code> and <code>B</code> in the above example.
</p>

We can also use explicit conversions to provide enough information
for Go compilers to deduce the types of typed named constants.
The above code snippet is equivalent to the following one,
in which <code>X</code>, <code>Y</code>, <code>A</code> and <code>B</code>
are all typed constants.

<pre class="line-numbers"><code class="language-go">const X = float32(3.14)

const (
	A, B = int64(-3), int64(5)
	Y    = float32(2.718)
)
</code></pre>

<p></p>

If a basic value literal is bound to a typed constant, the basic value
literal must be representable as a value of the type of the constant.
The following typed constant declarations are invalid.

<pre class="line-numbers"><code class="language-go">const a uint8 = 256             // error: 256 overflows uint8
const b = uint8(255) + uint8(1) // error: 256 overflows uint8
const c = int8(-128) / int8(-1) // error: 128 overflows int8
const MaxUint_a = uint(^0)      // error: -1 overflows uint
const MaxUint_b uint = ^0       // error: -1 overflows uint
</code></pre>

<p>
</p>

The following typed constant declaration is valid on 64-bit OSes,
but invalid on 32-bit OSes.
For each <code>uint</code> value has only 32 bits on 32-bit OSes.
<code>(1 << 64) - 1</code> is not representable as 32-bit values.

<pre class="line-numbers"><code class="language-go">const MaxUint uint = (1 << 64) - 1
</code></pre>

Then, how to declared a typed <code>uint</code> constant and bind
the largest <code>uint</code> value to it? Use the following way.

<pre class="line-numbers"><code class="language-go">const MaxUint = ^uint(0)
</code></pre>

Similarly, we can declare a typed <code>int</code> constant
and bind the largest <code>int</code> value to it.

<pre class="line-numbers"><code class="language-go">const MaxInt = int(^uint(0) >> 1)
</code></pre>

We can also similar ways to get the number of bits of a native word,
and check the currrent OS is 32-bit or 64-bit.

<pre class="line-numbers"><code class="language-go">const NativeWordBits = 32 << (^uint(0) >> 63) // 64 or 32
const Is64bitOS = ^uint(0) >> 63 != 0
const Is32bitOS = ^uint(0) >> 32 == 0
</code></pre>

<p>
</p>
</div>

<h4>Autocomplete In Constant Declarations</h4>

<div>

In a group-style constant declaration, except the first logic line,
other logic lines can be incomplete.
An incomplete logic line doesn't contain the <code>=</code> symbol.
Compilers will autocomplete the incomplete lines for us by
copying the missing part from the first preceding complete logic line.
For example, at compile time, compilers will automatically
complete the following code

<pre class="line-numbers"><code class="language-go">const (
	X float32 = 3.14
	Y                // here must be one identifier
	Z                // here must be one identifier

	A, B = "Go", "language"
	C, _
	// In the above line, the blank identifier is needed.
)
</code></pre>

as

<pre class="line-numbers"><code class="language-go">const (
	X float32 = 3.14
	Y float32 = 3.14
	Z float32 = 3.14

	A, B = "Go", "language"
	C, _ = "Go", "language"
)
</code></pre>

<p>
</p>

</div>

<h4><code>iota</code> In Constant Declarations</h4>

<div>

The autocomplete feature plus the <code>iota</code> constant generator
feature brings much convenience to Go programming.
<code>iota</code> is a predeclared constant
which can only be used in other constant declarations.
It is declared as
<pre class="line-numbers"><code class="language-go">const iota = 0
</code></pre>

<p>
But the value of an <code>iota</code> in code may be not always <code>0</code>.
When the predeclared <code>iota</code> constant is used in
a custom constant declaration, at compile time,
within the custom constant declaration,
its value will be reset to <code>0</code> at the first logic line
and will increase <code>1</code> logic line by logic line.
So <code>iota</code> is only useful in group-style constant declarations.
</p>

Here is an example using both the autocomplete
and the <code>iota</code> constant generator features.
Please read the comments to get what will happen at compile time.
The <code>+</code> symbol in this example is the addition operator.

<pre class="line-numbers"><code class="language-go">package main

func main() {
	const (
		k = 3 // now, iota == 0
	
		m float32 = iota + 0.1 // m float32 = 1 + 0.1
		n                      // n float32 = 2 + 0.1
	
		p = 9             // now, iota == 3
		q = iota * 2      // q = 4 * 2
		_                 // _ = 5 * 2
		r                 // r = 6 * 2
		s, t = iota, iota // s, t = 7, 7
		u, v              // u, v = 8, 8
		_, w              // _, w = 9, 9
	)

	const x = iota // x = 0
	const (
		y = iota // y = 0
		z        // z = 1
	)

	println(m, n)          // +1.100000e+000 +2.100000e+000
	println(q, r)          // 8 12
	println(s, t, u, v, w) // 7 7 8 8 9
	println(x, y, z)       // 0 0 1
}
</code></pre>

The above example is just to demo the rules of
the <code>iota</code> constant generator feature.
Surely, in practice, we should use it in more meaningful ways.
For example,

<pre class="line-numbers"><code class="language-go">const (
	Failed = iota - 1 // == -1
	Unknown           // == 0
	Succeeded         // == 1
)

const (
	Readable = 1 << iota // == 1
	Writable             // == 2
	Executable           // == 4
)
</code></pre>

<p>
Here, the <code>-</code> symbol is the subtraction operator,
and the <code>&lt;&lt;</code> symbol is the left-shift operator.
Both of the two operators will be introudced in the next article.
</p>

</div>

<p class="anchor" id="variable"></p>
<h3>Variables, Variable Declarations And Value Assigments</h3>

<div>
<p>
Variables are named values.
Variables are stored in memory at run time.
The value represented by a variable can be modified at run time.
</p>

<p>
All variables are typed values.
When declaring a variable, there must be sufficient information provided
for compilers to deduce the type of the variable.
</p>

<p>
The variables declared within function bodies are called local variables.
The variables declared out of any function body
are called package-level variables.
We also often call package-level variables as global variables.
</p>

<p>
There are two basic variable declaration forms,
the standard one and the short one.
The short form can only be used to delcared local variables.
</p>

<h4>Standard Variable Declarations Forms</h4>

<p>
Each standard declaration starts with the <code>var</code> keyword,
which is followed by the declared variable name.
Variable names must be <a href="keywords-and-identifiers.html#identifier">identifiers</a>.
</p>

The following are some full standard declaration forms.
In these declarations,
the types and initial values of the decalred variables are all specified.
<pre class="line-numbers"><code class="language-go">var lang, website string = "Go", "https://golang.org"
var compiled, dynamic bool = true, false
var announceYear int = 2008
</code></pre>

<p>
As we have found, multiple variables can be declared together
in one variable declaration.
Please note, there can be most one type specified in a variable declaration.
So the types of the multiple variables declared in the same declaration line must be identical.
</p>

<p>
Full standard variable declaration forms are seldom used in practice, for they are some verbose.
In practice, the two standard variable declaration variant forms introduced
below are used more often.
In the two variants, either the types or the initial values of
the declared variables are absent.
</p>

The following are some standard variable declarations without specifying variable types.
Compilers will deduce the types of the decalred variables as the types
(or default types) of their respective initial values.
The following declarations are equivalent to the above ones in fact.
Please note, in the following declarations, the types of the multiple variables
declared in the same declaration line can be different.
<pre class="line-numbers"><code class="language-go">// The types of the lang and dynamic variables will be
// deduced as "string" and "bool" by compilers, respectively.
var lang, dynamic = "Go", false

// The types of the compiled and announceYear variables will
// be deduced as "bool" and "int" by compilers, respectively.
var compiled, announceYear = true, 2009

// The types of the website variable will be deduced
// as "string" by compilers.
var website = "https://golang.org"
</code></pre>

<p>
The type deductions in the above example can be viewed as implicit conversions.
</p>

The following are some standard declarations without specifying variable initial values.
In these declarations, all declared variables are initialized
as the zero values of their respective types.
<pre class="line-numbers"><code class="language-go">var lang, website string      // both are initialized as blank strings.
var interpreted, dynamic bool // both are initialized as false.
var n int                     // is initialized as 0.
</code></pre>

<p>
</p>

Multiple variables can be grouped into one standard form declaration
by using <code>()</code>. For example:
<pre class="line-numbers"><code class="language-go">var (
	lang, bornYear, compiled     = "Go", 2007, true
	announceAt, releaseAt    int = 2009, 2012
	createdBy, website       string
)
</code></pre>

<p>
The above example is formatted by using the <code>go fmt</code> command
in the official Go SDK.
In the above example. each of the three lines enclosed in <code>()</code>
is called a variable specification.
</p>

<p>
Generally, declaring related variables together will
make code get a better readability.
</p>

</div>

<p class="anchor" id="assignment"></p>
<h4>Pure Value Assignments</h4>

<div>
<p>
In the above variable declarations, the sign <Code>=</code> means assignment.
Once a variable is declared, we can modify its value by using pure value assignments.
Like variable declarations, multiple values can be assigned in a pure assignment.
<p>

<p>
Later, if we say <b><i><code>x</code> is assignable to <code>y</code></i></b>,
what we mean is <code>x</code> is mutable, and the types of <code>x</code> and
<code>y</code> are identical, <code>y</code> can be implicitly converted to
the type of <code>x</code>, or <code>y</code> is
the blank identifier <code>_</code>.
If <code>y</code> is not the blank identifier <code>_</code>,
it must be either addressable, or a map index syntax.
(Map types will introduced later.)
</p>

<p>
Constants (immutable values) are all unaddressable, so they can't appear
at the left sides of pure value assignments.
Variables are all addressable, so they can appear
at the left sides of pure value assignments.
</p>

Example:
<pre class="line-numbers"><code class="language-go">const N = 123
var x int
var y, z float32

N = 789 // error: constant N is not modifiable
y = N   // okay: N is implicitly converted to (deduced as a) float32
x = y   // error: type mismatch
x = N   // okay: N is implicitly converted to (deduced as an) int
y = x   // error: type mismatch
z = y   // okay
_ = y   // okay

x, y = 69, 1.23           // okay
x, y = y, x               // error: type mismatch
x, y = int(y), float32(x) // okay
z, y = y, z               // okay
_, y = y, z               // okay
z, _ = y, z               // okay
_, _ = y, z               // okay
</code></pre>

<p>
The last line in the above example uses explicit conversions to
make the corresponding destination and soruce values matched.
The explicit conversion rules for non-constant numeric values
are introduced below.
</p>

Go doesn't support assignment chain. For example, the following code is illegal.
<pre class="line-numbers"><code class="language-go">var a, b int
a = b = 123 // syntax error
</code></pre>

<p>
</p>
</div>

<h4>Short Variable Declarations Forms</h4>

<div>
We can also use short variable declaration forms to declare variables.
Short variable declarations can only be used to delcare local variables.
Let's view an example which uses some short variable declarations.

<pre class="line-numbers"><code class="language-go">package main

func main() {
	// Both lang and year are two new declared variables.
	lang, year := "Go langauge", 2007

	// Only createdBy is a new declared variable.
	// The year variable has already been declared before,
	// so here its value is just modified.
	year, createdBy := 2009, "Google Research"

	// This is a pure assignment.
	lang, year = "Go", 2012

	print(lang, " is created by ", createdBy)
	println(", and released at year", year)
}
</code></pre>

<p>
</p>

There are several differences between short and standard variable declarations.
<ol>
<li>
	In a short delcaration form, the "var" keyword and
	variable types must be omitted. And the assignment sign
	must be <code>:=</code> instead of <code>=</code>.
</li>
<li>
	In a short variable delcaration, old variables and new
	variables can mix at the left of <code>:=</code>. But there must be
	at least one new variable at the left.
</li>
</ol>

<p>
Please note, there is a limition for short variable delcarations.
<b>In a short variable delcaration, all items at the left of the
<code>:=</code> sign must pure identifiers.</b>
This means some other assignable items,
which will be introduced in other articles,
can't appear at the left of <code>:=</code>.
These items include qualified identifiers, container elements,
pointer dereferences and struct field selectors.
Pure assignments have no such limition.
</p>

</div>

<h4>About The Terminology "Assignment"</h4>

<p>
Later, when the word "assignment" is mentioned,
it means a pure assignment, a short variable declaration,
or a variable specification with initial values
in a standard variable declaration.
</p>

<h4>Each Local Declared Variable Must Be Used At Least Once</h4>

<div>
<p>
Please note, for the standard Go compiler,
local variables are not allowed declared but unused.
Package-level variables have no such limit.
</p>

<p>
If a local variable is only ever used as destination values,
it will also be viewed as unused.
</p>

For example, compiler the following program

<pre class="line-numbers"><code class="language-go">package main

var x, y, z = 123, true, "foo" // package-level variables.

func main() {
	var q, r = 789, false
	r, s := true, "bar"
	r = y // r is unused.
	x = q // q is used.
}
</code></pre>

will result to the following compilation errors
(assume the source file is name <code>example-unused.go</code>):

<pre class="output"><code>./example-unused.go:6:6: r declared and not used
./example-unused.go:7:16: s declared and not used
</code></pre>

<p>
</p>

The fix is easy, we can assign <code>r</code> and <code>s</code>
to blank identifiers to avoid compilation errors.

<pre class="line-numbers"><code class="language-go">package main

var x, y, z = 123, true, "foo"

func main() {
	var q, r = 789, false
	r, s := true, "bar"
	r = y
	x = q

	_, _ = r, s // make r and s used.
}
</code></pre>

</div>

<h4>Dependency Relations Of Package-Level Variables Affect Their Initialization Order</h4>

<div>

For the following example,

<pre class="line-numbers"><code class="language-go">var x, y = a+1, 5         // 8 5
var a, b, c = b+1, c+1, y // 7 6 5 8
</code></pre>

<p>
the initialization order of the package-level variables are <code>y = 5</code>,
<code>c = y</code>, <code>b = c+1</code>, <code>a = b+1</code>,
and <code>x = a+1</code>.
</p>

<p>
Here, the <code>+</code> symbol is the addition operator,
which will be introudced in the next article. 
</p>

Pakcage-level variables can't be depended circularly in their declaration.
The following code fails to compile.

<pre class="line-numbers"><code class="language-go">var x, y = y, x
</code></pre>

</div>

<h3>Value Addressability</h3>

<p>
In Go, some values are addressable.
Addressable values can be taken addresses.
All variables are addressable and all constants are unaddressable.
We can learn more about addresses and pointers from the article
<a href="pointer.html">pointers in Go</a>
and learn other adressable and unadressable values from other articles later.
</p>

<h3>Explicit Conversions On Non-Constant Numeric Values</h3>

<div>
As above has mentioned, non-constant integer values can be converted to strings.
Here introduces two more legal non-constant numeric values
related conversion cases.
<ul>
<li>
	Non-constant floating-point and integer values can be explicitly
	converted to any other floating-point and integer types.
</li>
<li>
	Non-constant complex values can be explicitly
	converted to any other complex types.
</li>
</ul>

<p>
Unlike constant number conversions,
overflows are allowed in non-constant number conversions.
And when converting a non-constant floating-point value to an integer,
rounding is also allowed.
If a non-constant floating-point value doesn't overflow an interger type
the fraction part of the floating-point value will be discarded
(towards zero) when it is converted to the interger type.
</p>

<p>
In Go, two typed values of two different basic types
can't be assigned to each other.
In other words, the types of the destination and source values in an
assignment must be identical if the two values are both basic values.
If the type of the source basic value is not same as the type of
the destination basic value, then the source value must be explicitly
converted to the type of the distination value.
</p>

In the following example, the intended implicit conversions
at line <i>4</i> and line <i>11</i> both don't work.
<pre class="line-numbers"><code class="language-go">const a = -1.23
var b = a        // the type of b is deduced as float64.
var x = int32(a) // error: constant 1.23 truncated to integer.
var y int32 = b  // error: cannot assign float64 to int32.
var z = int32(b) // okay: z == -1, and the type of z is int32.
                 //       The fraction part of -1.23 is discarded.

const k int16 = 255
var n = k            // the type of n is deduced as int16.
var f = uint8(k + 1) // error: constant 256 overflows uint8.
var g uint8 = n + 1  // error: cannot assign int16 to uint8.
var h = uint8(n + 1) // okay: h == 0, and the type of h is uint8.
                     //       (n+1) overflows uint8 and is truncated.
</code></pre>

<p>
We can view the type deductions happen at line <i>2</i>
and line <i>9</i> are two implicit conversions,
where <code>a</code> and <code>k</code> are both converted to
their respective default type.
More implicit conversion rules will be introduced in other articles later.
</p>

</div>

<h3>Scopes Of Variables And Named Constants</h3>

<div>

In Go, we can use a pair of <code>{</code> and <code>}</code> to form a code block.
A code block can nest other code blocks.
A variable or a named constant declared in an inner code block will shadow
the variables and constants declared with the same name in outer code blocks.
For examples, the following program declares three distinct varialbes,
all of them are called <code>x</code>.
An inner <code>x</code> shadows an outer one.

<pre class="line-numbers"><code class="language-go">package main

const y = 789
var x int = 123

func main() {
	// The x variable shadows the package-level variable x.
	var x = true

	// A nested code block.
	{
		x, y := x, y // Here, the left x and y are both
		             // new declared variable. The right
		             // ones are declared in outer blocks.
		// In this code block, the just new declared x and y
		// shadow the outer declared same-name identifiers.
		x, z := !x, y/10 // only z is new declared.
		y /= 100
		println(x, y, z) // false 7 78
	}
	println(x) // true
	println(z) // error: z is undefined.
}
</code></pre>

<p>
Declared types and functions can also be shadowed.
</p>

<p>
The scope (visibility range in code) of a package-level variable
(or a named constant) is the whole package of the variable
(or the named constant) is declared in.
The scope of a local variable (or a named constant) begins at the end of
its declaration and ends at the end of its innermost containing code block.
This is why the last line in the <code>main</code> function
of the above example doesn't compile.
</p>

<p>
Code blocks and identifier scopes will be explained detailedly in
<a href="blocks-and-scopes.html">blocks and scopes</a> later.
</p>

</div>

<h3>More About Constant Declarations</h3>

<p>
Constant declarations can be viewed as enhanced <code>#define</code> macros in C.
A constant declaration define a named constant which represents a literal.
All the occurances of a named constant will be replaced with the literal
it represents at compile time.
</p>

<p>
If the two operands of an operator operation are both constants,
then the opeartion will be evaluated at compile time.
(Please read the next article
<a href="operators.html">common operators</a> for details.)
</p>

<div>
For example, at compile time, the follow code

<pre class="line-numbers"><code class="language-go">package main

const X = 3
const Y = X + X
var a = X

func main() {
	b := Y
	println(a, b, X, Y)
}
</code></pre>

will be viewed as

<pre class="line-numbers"><code class="language-go">package main

var a = 3

func main() {
	b := 6
	println(a, b, 3, 6)
}
</code></pre>

<p></p>

</div>



