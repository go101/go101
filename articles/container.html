<h1>Arrays, Slices And Maps In Go</h1>

<p>
Strictly speaking, there are three kinds of first-level citizen
container types in Go, array, slice and map.
Sometimes, strings and channels can also be viewed as container types,
but this article will not touch the two kinds of types.
All container types talked about in the current article are
arrays, slices and maps.
</p>

<p>
There are many container related details in Go.
This article will list them one by one.
</p>

<h3>Simple Overview Of Container Types And Values</h3>

<div>
<p>
Each value of the three kinds of types is used to
store a collection of element values.
The types of all the elements stored in a container value are identical.
The identical type is called the element type of
(the container type of) the container value.
</p>

<p>
Each element in a container has an associated key.
An element value can be accessed through its associated key.
The key types of map types must be
<a href="type-system-overview.html#types-not-support-comparison">comparable types</a>.
The key types of array and slice types are all the built-in type <code>int</code>.
The keys of the elements of an array or slice are non-negative integers
which mark the positions of these elements in the array or slice.
The non-negative integer keys are often called indexes.
</p>

<p>
Each container value has a length,
which indicates how many elements are stored in that container.
The valid range of the integer keys of an array or slice value is
from zero (inclusive) to the length (exclusive) of the array or slice.
For each value of a map type, the key values of that map value can be
an arbitrary value of the key type of the map type.
</p>

<p>
There are also many differences between the three kinds of container types.
Most of the differences originate from the differences between
the value memory layouts of the three kinds of types.
From the last article, <a href="value-part.html">value parts</a>,
we learned that an array value is composed of only one direct part,
however a slice or map value may have an underlying part,
which is referenced by the direct part of the slice or map value.
</p>

<p>
Elements of an array and a slice are both stored
contiguously in a continuous memory segment.
For an array, the continuous memory segment
hosts the direct part of the array.
For a slice, the continuous memory segment
hosts the underlying part of the slice.
The map implementaion of the standard Go compiler/runtime
adopts the hashtable algorithm.
So all elements of a map are also stored in an underlying
continuous memory segment, but they may be not contiguous.
There may be many holes (gaps) within the continuous memory segment.
</p>

<p>
Another common map implementation algorithm is the binary tree algorithm,
but the following desciptions assume that
the underlying structures of all maps are hashtables.
Whatever algorithm is used,
the keys associated with the elements of a map are also stored in the map.
</p>

<p>
We can access an element through its key.
The time complexities of element accessments on all container values
are all <code><i>O</i>(1)</code>,
though, generally map element accessments are several times
slower than array and slice element accessments.
</p>

<p>
Remember, the underlying parts of a value will not get copied
when the value is copied. In other words, if a value has underlying parts,
a copy of the value will share the the underlying parts with the value.
This is the root reason of many behavior differences
between array and slice/map values.
These behavior differences will be introduced below.
</p>

</div>

<h3>Literal Representations Of Unnamed Container Types</h3>

<div>
The literal representations of the three kinds of unnamed container types:
<ul>
<li>array types: <code>[N]T</code></li>
<li>slice types: <code>[]T</code></li>
<li>map types: <code>map[K]T</code></li>
</ul>

where
<ul>
<li>
	<code>T</code> is an arbitrary type.
	It specifies the element type of a container type.
	Only values of the specified element type can be stored
	as element values of values of the container type.
</li>
<li>
	<code>N</code> must be a non-negative integer constant.
	It specifies the number of elements stored in any value of an array type,
	and it can be called the length of the array type.
	This means the length of an array type is the inherent part of the array type.
	For example, <code>[5]int</code> and <code>[8]int</code>
	are two distinct array types.
</li>
<li>
	<code>K</code> is an arbitrary comparable type.
	It specifies the key type of a map type.
	Most types in Go are comparable, uncomparable types are
	<a href="type-system-overview.html#types-not-support-comparison">listed here</a>.
</li>
</ul>

Here are some container type literal representation examples:
<pre class="line-numbers"><code class="language-go">const Size = 32

type Person struct {
	name string
	age  int
}

// Array types.
[5]string
[Size]int
[16][]byte  // element type is a slice type: []byte
[100]Person // element type is a struct type: Person

// Slice types.
[]bool
[]int64
[]map[int]bool // element type is a map type: map[int]bool
[]*int         // element type is a pointer type: *int

// Map types.
map[string]int
map[int]bool
map[int16][6]string // element type is an array type: [6]string
map[struct{}]*int32 // element type is a pointer type: *int32,
                    // and value type is a struct type.
</code></pre>

<p>
</p>

<p>
We should try to avoid using large-size types as map key types.
For it needs more time to compare (and calculate hashes of) keys of such types.
</p>

<p>
The sizes of all slice types are the same.
The sizes of all map types are also the same.
The size of an array type depends on its length and the size of its element type.
The size of a zero-length array type or an array type
with a zero-size element type is zero.
</p>

</div>

<p class="anchor" id="value-literals"></p>
<h3>Container Value Literals</h3>

<div>
Like struct values, container values can also be represented
with composite literals, <code>T{...}</code>, where <code>T</code> is a type.
Here are some examples:
<pre class="line-numbers"><code class="language-go">// An array value which contains four bool values.
[4]bool{false, true, true, false}

// A slice value which contains three words.
[]string{"break", "continue", "fallthrough"}

// A map value which contains some key-value pairs.
map[string]int{"C": 1972, "Python": 1991, "Java", 1995, "Go": 2009}
</code></pre>

<p>
</p>

There are some variants for array and slice composite literals:
<pre class="line-numbers"><code class="language-go">// The followings slice composite literals are all equivalent.
[]string{"break", "continue", "fallthrough"}
[]string{0: "break", 1: "continue", 2: "fallthrough"}
[]string{2: "fallthrough", 1: "continue", 0: "break"}
[]string{2: "fallthrough", 0: "break", "continue"}

// The followings array composite literals are all equivalent.
[4]bool{false, true, true, false}
[4]bool{0: false, 1: true, 2: true, 3: false}
[4]bool{1: true, true}
[4]bool{2: true, 1: true}
[...]bool{false, true, true, false}
[...]bool{3: false, 1: true, true}
</code></pre>

<p>
In the last two literals, the <code>...</code>s mean we want to let compilers
deduce the lengths of array values represented by the literals.
</p>

<p>
The element values in a container composite literal must
be assignable to the corresponding container element type.
The key values in a map composite literal must
be assignable to the corresponding map key type.
</p>

<p>
From above examples, we know that element indexes (keys)
are optional in array and slice composite literals.
If an index is present,
it is not needed to be typed value of the key type <code>int</code>.
But it must be a non-negative constant representable
by a value of type <code>int</code>.
And if it is typed, its type must be a basic integer type.
An element which index is absent uses the previous element's index plus one.
If the index of the first element is absent, its index is zero.
</p>

<p>
The keys in a map literal can be non-constants.
<p>

<pre class="line-numbers"><code class="language-go">var a uint = 1
var _ = map[uint]int {a : 123} // okay
var _ = []int{a: 100}  // error: index must be non-negative integer constant
var _ = [5]int{a: 100} // error: index must be non-negative integer constant
</code></pre>

<p>
</p>

<p>
Constant keys in one specific composite literal can't be duplicated.
</p>

</div>

<h3>Literal Representations Of Zero Values Of Container Types</h3>

<p>
Like structs, the zero value of an array type <code>A</code> can be represented
with the composite literal <code>A{}</code>.
For example, the zero value of type <code>[100]int</code>
can be denoted as <code>[100]int{}</code>.
All elements stored in the zero value of an array type
are zero values of the element type of the array type.
</p>

<p>
Like pointer types, zero values of all slice and map types are represented
with the predeclared <code>nil</code>.
</p>

<p>
BTW, there are some other kinds of types whose zero values
are also represented by <code>nil</code>,
including pointer, function, channel and interface types.
Pointer types have been explained in <a href="pointer.html">pointers in Go</a>.
Other kinds of types will be explained in the following articles.
</p>

<p>
When an array variable is declared without being specified an initial value,
memory has been allocated for the elements of the zero array value.
The memory for the elements of a nil slice or map value has not been allocated yet.
</p>

<p>
Please note, <code>[]T{}</code> represents a blank slice value (with zero elements)
of slice type <code>[]T</code>, it is different with <code>[]T(nil)</code>.
The same situation is for <code>map[K]T{}</code> and <code>map[K]T(nil)</code>.
</p>

<p class="anchor" id="take-composite-literal-address"></p>
<h3>Compisite Literals Are Unaddressable But Can Be Taken Addresses</h3>

<div>
<p>
Compisite Literals are unaddressable values.
We have learned that
<a href="struct.html#take-composite-literal-address">struct composite literals
can be taken addresses directly</a> before.
Container composite literals have no exceptions here.
</p>

Example:
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	pm := &map[string]int{"C": 1972, "Go": 2009}
	ps := &[]string{"break", "continue"}
	pa := &[...]bool{false, true, true, false}
	fmt.Printf("%T\n", pm) // *map[string]int
	fmt.Printf("%T\n", ps) // *[]string
	fmt.Printf("%T\n", pa) // *[4]bool
}
</code></pre>
<p>
</p>
</div>

<p class="anchor" id="composite-literal-simplification"></p>
<h3>Nested Composite Literals Can Be Simplified</h3>

<div>
<p>
If a composite literal nested many other composite literals, then those nested
composited literals can simplified to the form <code>{...}</code>.
</p>

For example, the slice value literal

<pre class="line-numbers"><code class="language-go">// A slcie value of a type whose element type is *[4]byte.
// The element type is a pointer type whose base type is [4]byte.
// The pointer base type is an array type whose element type is byte.
var heads = []*[4]byte{
	&[4]byte{'P', 'N', 'G', ' '},
	&[4]byte{'G', 'I', 'F', ' '},
	&[4]byte{'J', 'P', 'E', 'G'},
}
</code></pre>

can be simplified to

<pre class="line-numbers"><code class="language-go">
var heads = []*[4]byte{
	{'P', 'N', 'G', ' '},
	{'G', 'I', 'F', ' '},
	{'J', 'P', 'E', 'G'},
}
</code></pre>

<p>
</p>

The array value literal in the following example
<pre class="line-numbers"><code class="language-go">type language struct {
	name string
	year int
}

var _ = [...]language{
	language{"C", 1972},
	language{"Python", 1991},
	language{"Go", 2009},
}
</code></pre>

can be simplified to

<pre class="line-numbers"><code class="language-go">var _ = [...]language{
	{"C", 1972},
	{"Python", 1991},
	{"Go", 2009},
}
</code></pre>

<p>
</p>

And the map value literal in the following example
<pre class="line-numbers"><code class="language-go">type LangCategory struct {
	dynamic bool
	strong  bool
}

// A value of map type whose key type is a struct type and
// whose element type is another map type "map[string]int".
var _ = map[LangCategory]map[string]int{
	LangCategory{true, true}: map[string]int{
		"Python": 1991,
		"Erlang": 1986,
	},
	LangCategory{true, false}: map[string]int{
		"JavaScript": 1995,
	},
	LangCategory{false, true}: map[string]int{
		"Go":   2009,
		"Rust": 2010,
	},
	LangCategory{false, false}: map[string]int{
		"C": 1972,
	},
}
</code></pre>

can be simplified to

<pre class="line-numbers"><code class="language-go">var _ = map[LangCategory]map[string]int{
	{true, true}: {
		"Python": 1991,
		"Erlang": 1986,
	},
	{true, false}: {
		"JavaScript": 1995,
	},
	{false, true}: {
		"Go":   2009,
		"Rust": 2010,
	},
	{false, false}: {
		"C": 1972,
	},
}
</code></pre>

<p>
Pleae notes, in the above several examples, the comma following the last item
in each composite literal can't be omitted.
Please read <a href="line-break-rules.html">the line break rules in Go</a>
for more information later.
</p>

</div>

<p class="anchor" id="comparison"></p>
<h3>Compare Container Values</h3>

<p>
As which has mentioned in the article
<a href="type-system-overview.html#types-not-support-comparison">overview of
Go type system</a>, map and slice types are uncomparable types.
So map and slice types can't be used as map key types.
</p>

<p>
Although a slice or map value can't be compared with another slice or map value
(or itself), it can be compared to the bare untyped <code>nil</code> identifier
to check whether or not the slice or map value is a zero value.
</p>

<p>
Most array types are comparable,
except the ones whose element types are uncomparable types.
</p>

<p>
When comparing two values of the same array type,
each of their elements will be compared.
The two array values are equal only if all of their corresponding elements are equal.
</p>

<div>
Example:
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	var a [16]byte
	var s []int
	var m map[string]int
	
	fmt.Println(a == a)   // true
	fmt.Println(m == nil) // true
	fmt.Println(s == nil) // true
	fmt.Println(nil == map[string]int{}) // false
	fmt.Println(nil == []int{})          // false
	
	// The following lines fail to compile.
	/*
	_ = m == m
	_ = s == s
	_ = m == map[string]int(nil)
	_ = s == []int(nil)
	var x [16][]int
	_ = x == x
	var y [16]map[int]bool
	_ = y == y
	*/
}
</code></pre>
<p>
</p>
</div>

<p class="anchor" id="element-accessment"></p>
<h3>Access And Modify Container Elements</h3>

<div>
<p>
The element associated to key <code>k</code> stored in a container value
<code>v</code> can be represented with the syntax form <code>v[k]</code>.

</p>

For a use of <code>v[k]</code>, assume <code>v</code> is an array or slice,
<ul>
<li>
	if <code>k</code> is a constant, then it must satisfy
	<a href="#value-literals">the requirements described above</a>
	for the indexes in container composite literals.
	In particular, if <code>v</code> is an array, the
	<code>k</code> must be smaller than the length of the array.
</li>
<li>
	if <code>k</code> is a non-constant value,
	it must be an integer and it must be larger than zero
	and smaller than <code>len(v)</code>,
	otherwise, a run-time panic will occur.
</li>
<li>
	if <code>v</code> is a nil slice,
	a run-time panic will occur.
</li>
</ul>

For a use of <code>v[k]</code>, assume <code>v</code> is a map,
then the type of <code>k</code> must be a comparable type.
<ul>
<li>
	If <code>k</code> is an uncomparable value (of a comparable type),
	a run-time panic will occur.
</li>
<li>
	If <code>k</code> is a comparable value, <code>v[k]</code> will
	cause a panic only if <code>v</code> is a nil map
	and <code>v[k]</code> is used as the destination value in an assignment.
</li>
<li>
	If <code>v[k]</code> is used as the source value in an assignment,
	no panics will occur, even if <code>v</code> is a nil map.
	(Assume the evaluation of <code>k</code> will not panic.)
</li>
<li>
	If <code>v[k]</code> is used as the source value
	and the map <code>v</code> doesn't contain an entry with
	key <code>k</code>, <code>v[k]</code> results a zero value of
	the element type of the corresponding map type of <code>v</code>.
	For most scenarios, <code>v[k]</code> is viewed as a single-valued
	expression. However, when <code>v[k]</code> is used as the only source
	value expression in an assignment, it can be viewed as a multi-valued
	expression and result a second optional untype boolean value,
	which indicates whether or not the map <code>v</code> contains an entry
	with key <code>k</code>.
</li>
</ul>

An example of container element accessments:
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	a := [3]int{-1, 0, 1}
	s := []bool{true, false}
	m := map[string]int{"abc": 123, "xyz": 789}
	fmt.Println (a[2], s[1], m["abc"])    // access
	a[2], s[1], m["abc"] = 999, true, 567 // modify
	fmt.Println (a[2], s[1], m["abc"])    // access
	
	n, present := m["hello"]
	fmt.Println(n, present, m["hello"]) // 0 false 0
	n, present = m["abc"]
	fmt.Println(n, present, m["abc"]) // 567 true 567
	m = nil
	fmt.Println(m["abc"]) // 0
	
	// The two lines fail to compile.
	/*
	_ = a[3]  // invalid array index 3 (out of bounds)
	_ = s[-1] // invalid slice index -1 (index must be non-negative)
	*/	

	// Each of the following lines causes a panic.
	_ = a[n]         // panic: runtime error: index out of range
	_ = s[n]         // panic: runtime error: index out of range
	m["hello"] = 555 // panic: assignment to entry in nil map
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="assignment"></p>
<h3>Container Assignments</h3>

<div>

<p>
If a map is assigned to another map, then the two maps will
share all (underlying) elements.
</p>

<p>
Like map assignments, if a slice is assigned to another slice,
they will share all (underlying) elements.
</p>

<p>
When an array is assigned to another array,
all the elements are copied from the source one to the destination one.
The two arrays don't share any elements.
</p>

Example:
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	m0 := map[int]int{0:7, 1:8, 2:9}
	m1 := m0
	m1[0] = 2
	fmt.Println(m0, m1) // map[0:2 1:8 2:9] map[0:2 1:8 2:9]
	
	s0 := []int{7, 8, 9}
	s1 := s0
	s1[0] = 2
	fmt.Println(s0, s1) // [2 8 9] [2 8 9]
	
	a0 := [...]int{7, 8, 9}
	a1 := a0
	a1[0] = 2
	fmt.Println(a0, a1) // [7 8 9] [2 8 9]
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="cap-len"></p>
<h3>Check Lengths And Capacities Of Container Values</h3>

<p>
Beside the length property, each container value also has a capactiy property.
The capacity of an array is always equal to the length of the array.
The capacity of a map is unlimited.
So, in practice, only capacities of slice values are meaningful.
The capacity of a slice is always equal to or larger than the length of the slice.
The meaning of slice capacities will be explained in the next section.
</p>

<p>
We can use the built-in <code>len</code> function to get the length of
a container value, and use the built-in <code>cap</code> function to
get the capacity of a container value.
Each of the two functions returns an <code>int</code> result.
As the capacity of any map value is unlimited,
the built-in <code>cap</code> function doesn't apply to map values.
</p>

<p>
The length and capacity of an array value can never change.
The length and capacity of a slice value may change at run time.
So slices can be viewed as dynamic arrays.
Slices are much more flexiable than arrays
and are used more popularly than arrays in practice.
</p>

<div>
Example:
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	var a [5]int
	fmt.Println(len(a), cap(a)) // 5 5
	var s []int
	fmt.Println(len(s), cap(s)) // 0 0
	s, s2 := []int{2, 3, 5}, []bool{}
	fmt.Println(len(s), cap(s), len(s2), cap(s2)) // 3 3 0 0
	var m map[int]bool
	fmt.Println(len(m)) // 0
	m, m2 := map[int]bool{1: true, 0: false}, map[int]int{}
	fmt.Println(len(m), len(m2)) // 2 0
}
</code></pre>

<p>
In the above example, the length and capacity of each slice value are equal.
This is not true for every slice values.
We will use some slices whose respective lengths and capacities are not equal
in the following sections.
</p>
</div>

<h3>Recall The Internal Structure Definition Of Slice Types</h3>

<div>
To understand slice types and values better and explain slices easier,
we need to have an impression on the internal structure of slice types.
From the last article, <a href="value-part.html">value parts</a>,
we learned that the internal structure of slice types
defined by the standard Go compiler/runtime is like
<pre class="line-numbers"><code class="language-go">type _slice struct {
	elements unsafe.Pointer // referencing underlying elements
	len      int            // length
	cap      int            // capacity
}
</code></pre>

<p>
The internal structure definitions used by other compilers/runtimes
implementations may be not the exact same but would be similar.
The following explanations are based on the official slice implementation.
</p>

<p>
The above shown internal structure explains the memory layouts of
the direct parts of slice values.
The <code>len</code> field of the direct part of a slice indicates
the length of the slice, and the <code>cap</code> field indicates
the capacity of the slice.
The following picture depicts the memory layout of a slice value.
<br/>
<img src="res/slice-internal.png">
<br/>
</p>

<p>
Although the underlying memory segment which hosts the elements of a slice
may be very large, the slice may be only aware of a sub-segment of the
memory segment. For example, in the above picture, the slice is only
aware of the middle grey sub-segment of the whole memory segment.
</p>

<p>
The next section will explain how to append elements to a base slice and yield
a new slice by using the built-in <code>append</code> function.
The result slice of an <code>append</code> function call may share starting
elements with the base slice or not, depending on the capacity (and length)
of the base slice and how many elements are appended.
</p>

For the slice depicted in the above picture, the elements from
index <code>len</code> to index <code>cap</code> (exclusive)
don't belong to the elements of the slice.
They are just some redundant element slots (for the depicted slice,
but they may be effective elements of other slices or another array).
</p>

When the slice is used as the base slice in an <code>append</code> function call,
<ul>
<li>
	if the number of appended elements is larger than the number of
	the redundant element slots of the base slice,
	a new underlying memory segment will be allocated for the result slice,
	thus the result slice and the base slice will not share any elements.
</li>
<li>
	otherwise, no new underlying memory segments will be allocated
	for the result slice, and the elements of the base slice also
	belong to the elements of the result slice.
	In other words, the two slices share some elements and all of
	their elements are hosted on the same underlying memory segment.
</li>
</ul>

<p>
The next section will show a picture which describes both of
the two possible cases in appending slice elements.
</p>

<p>
There are more routes which lead to the elements of two slices
are hosted on the same underlying memory segment.
Such as assignments and the below to be introduced subslice operations.
</p>

<p>
Note, generally, we can't modify the three fields of a slice value individually,
except through the <a href="#modify-slice-length-and-capacity">reflection</a>
and <a href="unsafe.html">unsafe</a> ways.
In other words, generally, to modify a slice value,
its three fields must be modified together.
Generally, this is achieved by copying/assigning another slice value
(of the same slice type) to the slice which needs to be modified.
</p>

</div>

<p class="anchor" id="element-addition-deletion"></p>
<h3>Append And Delete Container Elements</h3>

<div>
The syntax of appending a key-element pair (also called an entry)
to a map is the same as the syntax of modifying a map element.
For example, for a non-nil map value <code>m</code>,
the following line
<pre><code class="language-go">m[k] = e
</code></pre>

<p>
put the key-element pair <code>(k, e)</code> into the map <code>m</code>
if <code>m</code> doesn't contain an entry with key <code>k</code>,
or modify the element value associated with <code>k</code>
if <code>m</code> contains an entry with key <code>k</code>.
<p>

<p>
The underlying continuous memory segment of a map may need reallocated
to hold more and more elements.
</p>

There is a built-in <code>delete</code> function
which is used to delete an entry from a map.
For example, the following line will delete the entry with key
<code>k</code> from the map <code>m</code>.
If the map <code>m</code> doesn't contain an entry with key <code>k</code>,
it is a no-op, no panics will occur,
even if <code>m</code> is a nil map.
<pre><code class="language-go">delete(m, k)
</code></pre>

<p>
The entries stored in a map are not ordered by their orders of being appended.
Their orders are non-determinstic, we can think them are kind-of randomized.
</p>

An example shows how to append (put) elements to and delete elements from maps:
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	m := map[string]int{"Go": 2007}
	m["C"] = 1972     // append
	m["Java"] = 1995  // append
	fmt.Println(m)    // map[C:1972 Python:1991 Go:2007]
	m["Go"] = 2009    // modify
	delete(m, "Java") // delete
	fmt.Println(m)    // map[Go:2009 C:1972]
}
</code></pre>

<p>
</p>

<p>
Array elements can neither be appended nor deleted,
though elements of addressable arrays can be modified.
</p>

<p>
We can use the built-in <code>append</code> function
to append multiple elements into a base slice.
The result of the an <code>append</code> function call is a new slice
which contains the elements of the base slice and the appended elements.
Please note, the base slice is not modified
by the <code>append</code> function call.
Surely, if we expect, we can assign the result slice to the base slice
to modify the base slice.
</p>

<p>
There is not a built-in way to delete an element from a slice.
We must use the <code>append</code> function together with the subslice feature
introduced below to achieve this goal.
Slice element deletions and insertions will be demoed in the below
<a href="#slice-manipulations">more slice manipulations</a> section.
Here, the following example only shows how to append slice elements.
</p>

An example shows how to append elements to slices:
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	s0 := []int{2, 3, 5}
	s1 := append(s0, 7)      // append one element
	s2 := append(s1, 11, 13) // append two elements
	fmt.Println(s0, cap(s0)) // [2 3 5] 3
	fmt.Println(s1, cap(s1)) // [2 3 5 7] 6
	fmt.Println(s2, cap(s2)) // [2 3 5 7 11 13] 6
	s3 := append(s0)         // <=> s3 := s0
	s4 := append(s0, s0...)  // append all elements of s0
	fmt.Println(s3, cap(s3)) // [2 3 5] 3
	fmt.Println(s4, cap(s4)) // [2 3 5 2 3 5] 6
	s0[0], s1[0] = 99, 789
	fmt.Println(s2[0], s3[0], s4[0]) // 789 99 2
}
</code></pre>

<p>
Note, the built-in <code>append</code> function is a
<a href="function.html#variadic-function">variadic function</a>.
It has two parameters, the second one is a
<a href="function.html#variadic-parameter">variadic parameter</a>.
There are two manners to <a href="function.html#variadic-call">call variadic functions</a>.
In the above example, line <i>7</i>, line <i>8</i> and line <i>12</i> use
one manner and line <i>13</i> uses the other manner.
For the former manner, we can pass zero or more element values as the variadic arguments.
For the latter manner, we must pass a slice as the only variadic argument and
which must be followed by three dots <code>...</code>.
We can learn how to call variadic functions from the article
<a href="function.htm#variadic-call">function types and values</a> later.
</p>

Here, line <i>13</i> is equivalent to

<pre class="line-numbers"><code class="language-go">	s4 := append(s0, s0[0], s0[1], s0[2])
</code></pre>

<p>
For the three-dot <code>...</code> manner, the <code>append</code> doesn't
require the variadic argument must be a slice with the same type as the first
slice argument, but their element types must be identical.
</p>

In the above program,
<ul>
<li>
	the <code>append</code> call at line <i>7</i> will allocate a new
	underlying memory segment for slice <code>s1</code>,
	for slice <code>s0</code> doesn't have enough redundant element slots
	to store the new appended element. The same situation is for the
	<code>append</code> call at line <i>13</i>.
</li>
<li>
	the <code>append</code> call at line <i>8</i> will not allocate a new
	underlying memory segment for slice <code>s2</code>,
	for slice <code>s1</code> has enough redundant element slots
	to store the new appended elements.
</li>
</ul>

<p>
So, <code>s1</code> and <code>s2</code> share some elements,
<code>s0</code> and <code>s3</code> share all elements,
and <code>s4</code> doesn't share elements with others.
The following picture depicted the memory layouts of these slices
at the end of the above program.
<br/>
<img src="res/slice-append.png">
<br/>
</p>

<p>
Up to now (Go 1.10), the first arugment of an <code>append</code> function
call can't be an untyped <code>nil</code>.
</p>

</div>

<p class="anchor" id="make"></p>
<h3>Create Slices And Maps With The Built-in <code>make</code> Function</h3>

<div>
<p>
Beside using composite literals to create map and slice values,
we can also use the built-in <code>make</code> function to create map and slice values.
The built-in <code>make</code> function can't be used to create array values.
</p>

<p><i>
(The built-in <code>make</code> function can also be used to create
channels, which will be explained in the article
<a href="channel.html">channels in Go</a> later.)
</i></p>

Assume <code>M</code> is a map type and <code>n</code> is non-negative integer,
we can use the following two forms to create new maps of type <code>M</code>.
The first form creates a new empty map which is allocated with enough space to
hold the <code>n</code> elements.
The second form only takes one argument,
in which case a new empty map with enough space to
hold a small number of elements is allocated.
The small number is compiler dependent.
<pre class="line-numbers"><code class="language-go">make(M, n)
make(M)
</code></pre>

<p>
</p>

Assume <code>S</code> is a slice type, <code>length</code> and
<code>capacity</code> are two non-negative integers,
<code>length</code> is not larger than <code>capacity</code>,
we can use the following two forms to create new slices of type <code>S</code>.

<pre class="line-numbers"><code class="language-go">make(S, length, capacity)
make(S, length)
</code></pre>

<p>
The first form creates a new slice with the specified length and capacity.
The second form only takes two arguments, in which case the capacity of
the new created slice is the same as its length.
</p>

<p>
All the elements in the result slice of a <code>make</code> function call
are initialized as the zero value (of the slice element type).
</p>

An example on how to use the built-in <code>make</code> function
to create maps and slices:
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	// Make new maps.
	fmt.Println(make(map[string]int)) // map[]
	m := make(map[string]int, 3)
	fmt.Println(m, len(m)) // map[] 0
	m["C"] = 1972
	m["Go"] = 2009
	fmt.Println(m, len(m)) // map[C:1972 Go:2009] 2
	
	// Make new slices.
	s := make([]int, 3, 5)
	fmt.Println(s, len(s), cap(s)) // [0 0 0] 3 5
	s = append(s, 7, 11)
	fmt.Println(s, len(s), cap(s)) // [0 0 0 7 11] 5 5
	s = make([]int, 2)
	fmt.Println(s, len(s), cap(s)) // [0 0] 2
}
</code></pre>

<p>
</p>

</div>

<p class="anchor" id="new"></p>
<h3>Allocate Containers With The Built-in <code>new</code> Function</h3>

<div>
<p>
From the article <a href="pointer.html">pointers in Go</a>, we learned that
we can also call the built-in <code>new</code> function to allocate
a value of any type and get a pointer which references the allocated value.
The allocated value is a zero value of its type.
For this reason, it is a nonsense to use <code>new</code> function to
create map and slice values.
</p>

<p>
It is not totally a nonsense to allocate a zero value of an array type
with the built-in <code>new</code> fucntion.
However, it is seldom to do this in practice,
</p>

Example:
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	m := *new(map[string]int)   // <=> var m map[string]int
	fmt.Println(m == nil)       // true
	s := *new([]int)            // <=> var s []int
	fmt.Println(s == nil)       // true
	a := *new([5]bool)          // <=> var a [5]bool
	fmt.Println(a == [5]bool{}) // true
}
</code></pre>

<p>
Composite literals and the built-in <code>make</code> fucntion
are used more much popularly that the built-in <code>new</code> function
to create container values.
</p>

</div>

<h3>Addressability Of Container Elements</h3>

<div>
Following are some facts about the addressabilities of container elements.
<ul>
<li>
	Elements of addressable array values are also addressable.
	Elements of unaddressable array values are also unaddressable.
	The reason is each array value is only composed of one direct part.
</li>
<li>
	Elements of any slice value are always addressable,
	whether or not that slice value is addressable.
	This is because the elements of a slice are stored in
	the underlying value part of the slice and the underlying part
	is always hosted on an allocated memory segment.
</li>
<li>
	Elements of map values are always unaddressable.
	The reason is the underlying continuous memory segment of a map
	may need reallocated when the number of elements of the map grows.
	After a reallocation, all elements will be move to other places.
</li>
</ul>

For example:
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	a := [5]int{2, 3, 5, 7}
	s := make([]bool, 2)
	pa2, ps1 := &a[2], &s[1]
	fmt.Println(*pa2, *ps1) // 5 false
	a[2], s[1] = 99, true
	fmt.Println(*pa2, *ps1) // 99 true
	ps0 := &[]string{"Go", "C"}[0]
	fmt.Println(*ps0) // Go
	
	m := map[int]bool{1: true}
	_ = m
	// The following lines fail to compile.
	/*
	_ = &[3]int{2, 3, 5}[0]
	_ = &map[int]bool{1: true}[1]
	_ = &m[1]
	*/
}
</code></pre>

<p>
</p>

<p>
Unlike most other unaddressable values, which direct parts can not be modified,
the direct part of a map element values can be modified,
but can only be modified (overwritten) as a whole.
For most kinds of element types, this is not a big issue.
However, if the element type of map type is an array type or struct type,
things become some counter-intuitive.
</p>

From the last article, <a href="value-part.html">value parts</a>, we learned
that each of struct and array values is composed of only one direct part.
So
<ul>
<li>
	if the element type of a map is a struct type,
	we can not individually modify each field of an element of the map.
</li>
<li>
	if the element type of a map is an array type,
	we can not individually modify each element of an element
	(which is an array) of the map.
</li>
</ul>

Example:
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	type T struct{age int}
	mt := map[string]T{}
	mt["John"] = T{age: 29}
	ma := map[int][5]int{}
	ma[1] = [5]int{1: 789}
	
	// Accessments are ok
	fmt.Println(ma[1][1]) // 789
	fmt.Println(mt["John"].age) // 29
	
	// The following two modifications fail to compile.
	/*
	ma[1][1] = 123      // error: cannot assign to a[1][1]
	mt["John"].age = 30 // cannot assign to struct field
	                    // mt["John"].age in map.
	*/
}
</code></pre>

<p>
</p>

To make any expected modification work in the above example,
the curresponding map element should be saved in a temporary variable firstly,
then the temporary variable is modified as needed, in the end
the curresponding map element is overwritten by the temporary variable.
For example,

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	type T struct{age int}
	mt := map[string]T{}
	mt["John"] = T{age: 29}
	ma := map[int][5]int{}
	ma[1] = [5]int{1: 789}
	
	t := mt["John"] // a temporary copy
	t.age = 30
	mt["John"] = t // overwrite it back
	
	a := ma[1] // a temporary copy
	a[1] = 123
	ma[1] = a // overwrite it back
	
	fmt.Println(ma[1][1], mt["John"].age) // 123 30
}
</code></pre>

</div>

<p class="anchor" id="subslice"></p>
<h3>Derive Slices From Arrays And Slices</h3>

<div>
<p>
We can derive a new slice from an array or slice
by using the subslice syntax forms.
The elements of the derived slice and the base array or slice
are hosted on the same underlying continuous memory segment.
In other words, the derived slice and the base array or slice
may share some contiguous elements.
</p>

There are two subslice syntax forms (<code>baseContainer</code> is an array or slice):
<pre class="line-numbers"><code class="language-go">baseContainer[low : high]       // two-index form
baseContainer[low : high : max] // three-index form
</code></pre>

The two-index form is equivalent to
<pre class="line-numbers"><code class="language-go">baseContainer[low : high : cap(baseContainer)]
</code></pre>

<p>
So the two-idnex form is a special case of the three-index form.
The two-index form is used munch more popularly
than the three-index form in practice.
</p>

<p>
Note, the three-index form is only supported for Go 1.2+.
<p>

In a subslice expression, the <code>low</code>, <code>high</code> and
<code>max</code> indexes must satisfy the following requirements:
<ul>
<li>
	<code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(baseContainer)</code>.
</li>
<li>
	<code>low &lt;= len(baseContainer)</code>.
</li>
</ul>

<p>
Indexes not satisfying these requirements may make the subslice expression
fail to compile at compile time or panic at run time,
depending on the base container type kind
and whether or not the indexes are constants.
</p>

Note,
<ul>
<li>
	the <code>high</code> index can be larger than
	<code>len(baseContainer)</code>, but must not larger than
	<code>cap(baseContainer)</code>, if <code>baseContainer</code> is a slice
	and <code>len(baseContainer)</code> is smaller than <code>cap(baseContainer)</code>.
</li>
<li>
	a subslice expression will not cause a panic if the base container
	is a nil slice and all indexes used in the expression are zero.
	The result slice derived from a nil slice is still a nil slice.
</li>
</ul>

<p>
The length of the result derived slice is equal to <code>high - low</code>, and
the capacity of the result derived slice is equal to <code>max - low</code>.
The length of a derived slice may be larger than the base container,
but the capacity will never be larger than the base container.
</p>

In pratice, for simplicity, we often omitted some indexes in subslice syntax forms.
The omission rules are:
<ul>
<li>
	if the <code>low</code> index is equal to zero, it can be omitted,
	either for two-index or three-index forms.
</li>
<li>
	if the <code>high</code> is equal to <code>len(baseContainer)</code>,
	it can be omitted, but only for two-index forms.
</li>
<li>
	the <code>max</code> can never be omitted in three-index forms.
</li>
</ul>

For example, the following expressions are equivalent.
<pre class="line-numbers"><code class="language-go">baseContainer[0 : len(baseContainer)]
baseContainer[: len(baseContainer)]
baseContainer[0 :]
baseContainer[:]
baseContainer[0 : len(baseContainer) : cap(baseContainer)]
baseContainer[: len(baseContainer) : cap(baseContainer)]
</code></pre>

An example of using subslice syntax forms:
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	a := [...]int{0, 1, 2, 3, 4, 5, 6}
	s0 := a[:]
	s1 := s0[:]   // <=> s1 := s0[0:7] <=> s1 := s0
	s2 := s1[1:3] // <=> s2 := s1[1:3] <=> s2 := a[1:3]
	s3 := s2[2:6] // <=> s3 := s2[2:6] <=> s3 := s1[3:7]
	s4 := s0[3:5] // <=> s4 := s0[3:5:7]
	s5 := s0[3:5:5]
	s6 := append(s4, 77)
	s7 := append(s5, 88)
	s8 := append(s7, 66)
	s3[1] = 99
	fmt.Println(len(s2), cap(s2), s2) // 2 6 [1 2]
	fmt.Println(len(s3), cap(s3), s3) // 4 4 [3 99 77 6]
	fmt.Println(len(s4), cap(s4), s4) // 2 4 [3 99]
	fmt.Println(len(s5), cap(s5), s5) // 2 2 [3 99]
	fmt.Println(len(s6), cap(s6), s6) // 3 4 [3 99 77]
	fmt.Println(len(s7), cap(s7), s7) // 3 4 [3 4 88]
	fmt.Println(len(s8), cap(s8), s8) // 4 4 [3 4 88 66]
}
</code></pre>

<p>
The following picture depicts the final memory layouts of the array
and slice values used in the above example.
<br/>
<img src="res/slice-subslice.png">
<br/>
</p>

<p>
From the picture, we know that the elements of slice <code>s7</code> and <code>s8</code>
are hosted on a different underlying memory segment than the other containers.
The elements of the other slices are hosted on the same memory segment
hosting the array <code>a</code>.
</p>

</div>

<p class="anchor" id="copy-slice-elements"></p>
<h3>Copy Slice Elements With The Built-in <code>copy</code> Function</h3>

<div>
<p>
We can use the built-in <code>copy</code> function to copy elements from one
slice to another, the types of the two slices are not required to be identical,
but their element types must be identical.
The first argument of the <code>copy</code> function is the destination slice
and the second one is the source slice.
The two arguments can overlap some elements.
The <code>copy</code> function returns the number of elements copied,
which will be the smaller one of the lengths of the two arguments.
<p>

<p>
With the help of the subslice syntax, we can use the <code>copy</code> function to
copy elements between two arrays or between an array and a slice.
</p>

An example:
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	type Ta []int
	type Tb []int
	dest := Ta{1, 2, 3}
	src := Tb{5, 6, 7, 8, 9}
	n := copy(dest, src)
	fmt.Println(n, dest) // 3 [5 6 7]
	n = copy(dest[1:], dest)
	fmt.Println(n, dest) // 2 [5 5 6]
	
	a := [4]int{} // an array
	n = copy(a[:], src)
	fmt.Println(n, a) // 4 [5 6 7 8]
	n = copy(a[:], a[2:])
	fmt.Println(n, a) // 2 [7 8 7 8]
}
</code></pre>

<p>
</p>

In fact, the <code>copy</code> function is not very essential.
We can implement it by using the built-in <code>append</code> function,
though our implementation doesn't support generic.

<pre class="line-numbers"><code class="language-go">// Assume element type is T.
func Copy(dest, src []T) int {
	if len(dest) < len(src) {
		_ = append(dest[:0], src[:len(dest)]...)
		return len(dest)
	} else {
		_ = append(dest[:0], src...)
		return len(src)
	}
}
</code></pre>

<p>
Although the <code>copy</code> function is not an essential function in Go,
for many circumstances, it is more convenient that the just shown way.
</p>

<p>
From another point of view, the <code>append</code> function can also be viewed
as a non-essential function (whereas <code>copy</code> is viewed as an
essential function), for all its uses can be implemented with
<code>make</code> and <code>copy</code> function calls.
</p>

<p>
Note, as a special case, the built-in <code>copy</code> function
can be used to <a href="string.html#use-string-as-byte-slice">copy bytes
from a string to a byte slice</a>.
</p>

<p>
Up to now (Go 1.10), neither of the two arugments of a <code>copy</code>
function call can be an untyped <code>nil</code> value.
</p>

</div>

<p class="anchor" id="iteration"></p>
<h3>Container Element Iterations</h3>

<div>
<p>
In Go, keys and elements of a container value can be iterated with
the following syntax:
<pre><code class="language-go">for key, element = range aContainer {
	// use key and element ...
}
</code></pre>
where <code>key</code> and <code>element</code> are called iteration variables.
The assignment sign <code>=</code> can be a short variable declaration sign
<code>:=</code>, in which case the two iteration variables are both two new
declared variables which are only visible within the <code>for-range</code>
code block body.
</p>

<p>
Like the traditional <code>for</code> loop block, each <code>for-range</code>
loop block creates two code blocks, an implicit one and an explicit one
which is formed by using <code>{}</code>.
The explicit one is nested in the implicit one.
</p>

<p>
Like <code>for</code> loop blocks, <code>break</code> and <code>continue</code>
statements can also be used in <code>for-range</code> loop blocks,
</p>

Example:
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	m := map[string]int{"C": 1972, "C++": 1983, "Go": 2009}
	for lang, year := range m {
		fmt.Printf("%v: %v \n", lang, year)
	}
	
	a := [...]int{2, 3, 5, 7, 11}
	for i, prime := range a {
		fmt.Printf("%v: %v \n", i, prime)
	}
	
	s := []string{"go", "defer", "goto", "var"}
	for i, keyword := range s {
		fmt.Printf("%v: %v \n", i, keyword)
	}
}
</code></pre>

<p>
If the iteration variable <code>i</code> in the above example is declared
outside of the <code>for-range</code> code block,
its type must be the built-in type <code>int</code>.
</p>

The form <code>for-range</code> code block syntax has several variants:
<pre class="line-numbers"><code class="language-go">// Ignore the key iteration variable.
for _, element = range aContainer {
	// ...
}

// Ignore the element iteration variable.
for key, _ = range aContainer {
	element = aContainer[key]
	// ...
}

// The element iteration variable is omitted.
// This form is equivalent to the last one.
for key = range aContainer {
	element = aContainer[key]
	// ...
}

// Ignore both the key and element iteration variables.
for _, _ = range aContainer {
	// This variant is not much useful.
}

// Both the key and element iteration variables are omitted.
// This form is equivalent to the last one.
for range aContainer {
	// This variant is not much useful.
}
</code></pre>

<p>
Iterating over nil maps or nil slices is allowed,
the number of iterated key-element pairs is zero for such cases.
</p>

Some details about iterations over maps are lsit here.
<ul>
<li>
	For a map, the entry order in an iteration is not guaranteed to be the
	same as the next iteration, even if the map is not modified between
	the two iterations. By Go specification, the order is randomized.
</li>
<li>
	If a map entry (a key-element pair) which has not yet been reached
	is removed during an iteration, then the entry will not
	iterated in the same iteration for sure.
</li>
<li>
	If a map entry is created during an iteration,
	that entry may be iterated during the same iteration, or not.
</li>
</ul>

If it is promised that there are no other goroutines
manipulating a map <code>m</code>, then the following code is guaranteed to
clear all key-element pairs stored in the map <code>m</code>:
<pre class="line-numbers"><code class="language-go">for key := range m {
	delete(m, key)
}
</code></pre>

<p>
</p>

Surely, array and slice elements can also be iterated by using the traditional <code>for</code> loop block:
<pre class="line-numbers"><code class="language-go">for i := 0; i < len(anArrayOrSlice); i++ {
	element := anArrayOrSlice[i]
	// ...
}
</code></pre>

<p>
</p>

For a <code>for-range</code> loop block

<pre class="line-numbers"><code class="language-go">for key, element = range aContainer {...}
</code></pre>

there are three important facts.

<ol>
<li>
	The ranged container is <b>a copy</b> of <code>aContainer</code>.
	However, please note, <a href="value-part.html#about-value-copy">only
	the direct part of <code>aContainer</code> is copied</a>.
	The copied container is anonymous, so there are no ways to modify it.
	<ul>
	<li>
		If the <code>aContainer</code> is an array, then the
		modifications made on the array elements during the iteration
		will not be reflected to the iteration variables.
		The reason is that the clone of the array doesn't
		share elements with the array.
	</li>
	<li>
		If the <code>aContainer</code> is a slice or map, then the
		modifications made on the slice or map elements during
		the iteration will be reflected to the iteration variables.
		The reason is that the clone of the slice (or map)
		shares all elements (entries) with the slice (or map).
	</li>
	</ul>
</li>
<li>
	A key-element pair of the copy of <code>aContainer</code> will be
	assigned (copied) to the iteration variables at each iteration step,
	so the modifications made on <b>the direct parts</b>
	of the iteration variables will not be refelcted to the elements
	(and keys for maps) stored in <code>aContainer</code>.
</li>
<li>
	All key-element pairs will be assigned to the <b>same</b>
	iteration variables.
</li>
</ol>

An example which proves the first and second facts.

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	type Person struct {
		name string
		age  int
	}
	persons := [2]Person {{"Alice", 28}, {"Bob", 25}}
	for i, p := range persons {
		fmt.Println(i, p)
		// This modification has no effects on the iteration,
		// for the ranged array is a copy of the persons array.
		persons[1].name = "Jack"
		// This modification has not effects on the persons array,
		// for p is just a copy of a copy of one persons element.
		p.age = 31
	}
	fmt.Println("persons:", &persons)
}
</code></pre>

The output:
<pre class="output"><code>0 {Alice 28}
1 {Bob 25}
persons: &[{Alice 28} {Jack 25}]
</code></pre>

<p>
</p>

If we change the array in the above to a slice, then the modification on the
slice during the iteration has effects on the iteration, but
the modification on the iteration variable still has no effects on the slice.

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	type Person struct {
		name string
		age  int
	}
	persons := []Person {{"Alice", 28}, {"Bob", 25}} // a slice
	for i, p := range persons {
		fmt.Println(i, p)
		// Now this modification has effects on the iteration.
		persons[1].name = "Jack"
		// This modification still has no any real effects.
		p.age = 31
	}
	fmt.Println("persons:", &persons)
}
</code></pre>

The output becomes to:
<pre class="output"><code>0 {Alice 28}
1 {Jack 25}
persons: &[{Alice 28} {Jack 25}]
</code></pre>

<p>
</p>

An example to prove the second and third facts.
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	langs := map[struct{ dynamic, strong bool }]map[string]int{
		{true, false}:  {"JavaScript": 1995},
		{false, true}:  {"Go": 2009},
		{false, false}: {"C": 1972},
	}
	// The key type and element type of this map are both
	// pointer types. Some weird, just for education purpose.
	m0 := map[*struct{ dynamic, strong bool }]*map[string]int{}
	for category, langInfo := range langs {
		m0[&category] = &langInfo
		// This following line has no real effects on langs.
		category.dynamic, category.strong = true, true
	}
	m1 := map[struct{ dynamic, strong bool }]map[string]int{}
	for category, langInfo := range m0 {
		m1[*category] = *langInfo
	}
	// m0 and m1 both contain only one entry.
	fmt.Println(len(m0), len(m1), m1)
	for category, langInfo := range langs {
		fmt.Println(category, langInfo)
	}
}
</code></pre>

As above has mentioned, the entry iteration order is randomized,
so the output of the above program may be also randomized.
One possible output:
<pre class="output"><code>1 1 map[{true true}:map[C:1972]]
{true false} map[JavaScript:1995]
{false true} map[Go:2009]
{false false} map[C:1972]
</code></pre>

<p>
</p>

<p>
The cost of copying a slice or map is small, but the cost of copying an array
is large if the size of the array type is large.
So, generally, it is not a good idea to range over a large array.
We can range over a slice derived from the array, or range over a pointer
to the array (see the next section for details).
</p>

For an array or slice, if the size of its element type is large, then,
generally, it is also not a good idea to use the second iteration variable to
store the iterated element at each loop step.
For such arrays and slices, we should use the one-iteration-variable
<code>for-range</code> loop variant or the traditional <code>for</code>
loop to iterate their elements.
In the following example, the loop in function <code>fa</code> is much less
efficient than the loop in function <code>fb</code>.

<pre class="line-numbers"><code class="language-go">type Buffer struct {
	start, end int
	data       [1024]byte
}

func fa(buffers []Buffer) int {
	numUnreads := 0
	for _, buf := range buffers {
		numUnreads += buf.end - buf.start
	}
	return numUnreads
}

func fb(buffers []Buffer) int {
	numUnreads := 0
	for i := range buffers {
		numUnreads += buffers[i].end - buffers[i].start
	}
	return numUnreads
}
</code></pre>

<p>
</p>

</div>

<p class="anchor" id="use-pointer-as-array"></p>
<h3>Use Array Pointers As Arrays</h3>

<div>
<p>
In many situations, we can use a pointer to an array as the array.
</p>

We can range over a pointer to an array to iterate the elements of the array.
For arrays with large lengths, this way is much more efficient, for copying
a pointer is much more efficient than copying a large-size array.
In the following example, the two loop blocks are equivalent
and both are efficient.
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	var a [100]int
	
	for i, n := range &a { // copying a pointer is cheap
		fmt.Println(i, n)
	}
	
	for i, n := range a[:] { // copying a slice is cheap
		fmt.Println(i, n)
	}
}
</code></pre>

<p>
</p>

If the second iteration is neither ignored nor omitted, then range over a nil
array pointer will panic. In the following example, each of the first two loop
blocks will print five indexes, however, the last one will produce a panic.

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	var p *[5]int // nil
	
	for i, _ := range p { // okay
		fmt.Println(i)
	}
	
	for i := range p { // okay
		fmt.Println(i)
	}
	
	for i, n := range p { // panic
		fmt.Println(i, n)
	}
}
</code></pre>

<p>
</p>

Array pointers can also used to index array elements.
Indexing array eleemnts through a nil array pointer produces a panic.
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	a := [5]int{2, 3, 5, 7, 11}
	p := &a
	p[0], p[1] = 17, 19
	fmt.Println(a) // [17 19 5 7 11]
	p = nil
	p[0] = 31 // panic
}
</code></pre>

<p>
</p>

We can also derived slices from array pointers.
Deriving slices from a nil array pointer produce a panic.

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	pa := &[5]int{2, 3, 5, 7, 11}
	s := pa[1:3]
	fmt.Println(s) // [3 5]
	pa = nil
	s = pa[1:3] // panic
}
</code></pre>

<p>
</p>

We can also pass array pointers as the arguments of the built-in
<code>len</code> and <code>cap</code> functions.
Nil array pointer arguments for the two functons will not produce panics.

<pre class="line-numbers"><code class="language-go">var pa *[5]int // nil
fmt.Println(len(pa), cap(pa)) // 5 5
</code></pre>

<p>
</p

</div>

<p class="anchor" id="memclr"></p>
<h3>The <code>memclr</code> Optimization</h3>

<div>
Assume <code>t0</code> is a literal presentation of the zero value of
type <code>T</code>, and <code>a</code> is an array which element type is
<code>T</code>, then the standard Go compiler will translate the following
one-iteration-variable <code>for-range</code> loop block
<pre class="line-numbers"><code class="language-go">for i := range a {
	a[i] = t0
}
</code></pre>
<p>
to an <a href="https://github.com/golang/go/issues/5373">internal
<code>memclr</code> call</a>, generally which is faster
than resetting each element one by one.
</p>

The optimization also works if the ranged container is a slice. Sadly,
it doesn't work if the ranged value is an array pointer (up to Go 1.10).
So if you want to reset an array, don't range its pointer. In particular,
it is recommended to range a slice derived from the array, like this:

<pre class="line-numbers"><code class="language-go">s := a[:]
for i := range s {
	s[i] = t0
}
</code></pre>

<p>
The reason of why is is recommended to range over a derived slice is
it is very possible that other Go compilers don't make the above optimization,
and as above has mentioned, ranging over an array will make a copy
of the array (though the standard Go compiler won't in this optimization).
</p>

</div>

<p class="anchor" id="compile-time-evaluation"></p>
<h3>Calls To The Built-in <code>len</code> And <code>cap</code> Functions May Be Evaluated At Compile Time</h3>

<div>
<p>
If the argument passed to a built-in function <code>len</code> or
<code>cap</code> function call is an array or an array pointer value,
then the call is evaluated at compile time and the ressult of the call
is a typed constant with default type as the built-in type <code>int</code>.
The result can be bound to named constants.
</p>

Example:
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

var a [5]int
var p *[7]string

// N and M are both typed constants.
const N = len(a)
const M = cap(p)

func main() {
	fmt.Println(N) // 5
	fmt.Println(M) // 7
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="modify-slice-length-and-capacity"></p>
<h3>Modify The Length And Capacity Properties Of A Slice Individually</h3>

<div>
<p>
As above has mentioned, generally, the length and capacity of
a slice value can't be modified individually.
A slice value can only be overwritten as a whole
by assigning another slice value to it.
However we can modify the length and capacity of a slice
individually by using reflections.
</p>

Example:
<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
	"reflect"
)

func main() {
	s := make([]int, 2, 6)
	fmt.Println(len(s), cap(s)) // 2 6
	
	reflect.ValueOf(&s).Elem().SetLen(3)
	fmt.Println(len(s), cap(s)) // 3 6
	
	reflect.ValueOf(&s).Elem().SetCap(5)
	fmt.Println(len(s), cap(s)) // 3 5
}
</code></pre>

<p>
The argument passed to the <code>reflect.SetLen</code> function must not
be larger than the current capacity of the argument slice <code>s</code>.
The argument passed to the <code>reflect.SetCap</code> function must not
be smaller than the current length of the argument slice <code>s</code> and
larger than the current capacity of the argument slice <code>s</code>.
</p>

<p>
The reflection way is very inefficient, it is slower than a slice assignment.
</p>
</div>

<p class="anchor" id="slice-manipulations"></p>
<h3>More Slice Manipulations</h3>

<p>
Go doesn't support more slice operations, such as slice clone,
element deletion and insertion, in the built-in way.
We must compose the built-in ways to achieve those operations.
</p>

<p>
In the following examples in the current section,
assume <code>s</code> is the talked slice,
<code>T</code> is its element type and <code>t0</code>
is a zero value literal representation of <code>T</code>.
</p>

<h4>Clone Slices</h4>

<div>
Up to the official Go SDK 1.10, the best way to clone a slice
is to use the following way.
<pre class="line-numbers"><code class="language-go">sClone := append(s[:0:0], s...)
</code></pre>

For slices with large lengths (throunsands of elements),
the above way is more efficient than
<pre class="line-numbers"><code class="language-go">sClone := make([]T, len(s))
copy(sClone, s)
</code></pre>

<p>
The second way is not perfect as the first one.
If <code>s</code> is a nil slice, the second way result a non-nil clone.
</p>

</div>

<h4>Delete A Segment Of Slice Elements</h4>

<div>
Above has mentioned that the elements a slice are stored contiguously
in memory and there are no gaps between any two adjacent elements of the slice.
So when a slice element is removed,
<ul>
<li>
	if the element order must be preserved,
	then each of the subsequent elements followed the removed element
	must be moved forwards.
</li>
<li>
	if the element order doesn't need to be preserved,
	then we can move the last element in the slice to the removed index.
</li>
</ul>

In the following example, assume <code>from</code> and <code>to</code> are
two legal indexes, <code>from</code> is not larger than <code>to</code>,
and the <code>to</code> index is exclusive.
<pre class="line-numbers"><code class="language-go">// way 1 (preserve element orders):
s = append(s[:from], s[to:]...)

// way 2 (preserve element orders):
s = s[:from + copy(s[from:], s[to:])]

// Don't preserve element orders:
copy(s[from:to], s[len(s)+from-to:])
s = s[:len(s)+from-to]
</code></pre>

If the slice elements contain pointers, we should reset
tail elements in the old slice to avoid memory leaking.

<pre class="line-numbers"><code class="language-go">// "len(s)+to-from" is the old slice length.
temp := s[len(s):len(s)+to-from]
for i := range temp {
	temp[i] = t0
}
</code></pre>

<p>
As above has mentioned, the <code>for-range</code> loop code block will be
optimized as a <code>memclr</code> call by the standard Go compiler.
</p>

</div>

<h4>Delete one Slice Element</h4>

<div>
<p>
Deleting one element is similar to, and also simpler than,
deleting a segment of elements.
</p>

In the following example,
assume <code>i</code> the index of the element to be removed
and <code>i</code> is a legal index.

<pre class="line-numbers"><code class="language-go">// Way 1 (preserve element orders):
s = append(s[:i], s[i+1:]...)

// Way 2 (preserve element orders):
s = s[:i + copy(s[i:], s[i+1:])]

// There will be len(s)-i-1 elements being copied in
// in either of the above two ways.

// Don't preserve element orders:
s[i] = s[len(s)-1]
s = s[:len(s)-1]
</code></pre>

<p>
</p>

If the slice elements contain pointers, then after the deletion action,
we should reset the last element of the old slice value
to avoid memory leaking:
<pre class="line-numbers"><code class="language-go">s[len(s):][0] = t0
</code></pre>

<p>
</p>
</div>

<h4>Delete Slice Elements Conditionally</h4>

<div>
Sometimes, we may need to delete slice elements by some conditions.

<pre class="line-numbers"><code class="language-go">// Assume T is a small-size type.
func DeleteElements(s []T, shouldKeep func(T) bool, clear bool) []T {
	result := make([]T, 0, len(s))
	for _, v := range s {
		if shouldKeep(v) {
			result = append(result, v)
		}
	}
	if clear { // avoid memory leaking
		temp := s[len(result):]
		for i := range temp {
			temp[i] = t0 // t0 is a zero value literal of T.
		}
	}
	return result
}
</code></pre>

</div>

<h4>Insert A Slice Into Another One</h4>

<div>
Assume the insertion position is a legal index <code>i</code>
and the slice to be inserted is called <code>elements</code>.

<pre class="line-numbers"><code class="language-go">// One-line implementation:
s = append(s[:i], append(elements, s[i:]...)...)

// A more efficient but more verbose way:
if cap(s)-len(s) >= len(elements) {
	s = s[:len(s)+len(elements)]
	copy(s[i+len(elements):], s[i:])
	copy(s[i:], elements)
} else {
	x := make([]T, 0, len(elements)+len(s))
	x = append(x, s[:i]...)
	x = append(x, elements...)
	x = append(x, s[i:]...)
	s = x
}

// Push:
s = append(s, elements...)

// Unshift:
s = append(elements, s...)
</code></pre>

<h4>Insert Several Slice Elements</h4>

<p>
Inserting several elements is similar to inserting a slice.
We can construct a slice with a slice composite literal with the elements
to be inserted, then use the above ways to insert the new slice.
</p>

<h4>Special Deletions And Insertions: Push Front/Back, Pop Front/Back</h4>

<div>
Assume the pushed or popped element is <code>e</code> and slice
<code>s</code> has at least one element.

<pre class="line-numbers"><code class="language-go">// Pop front:
s, e = s[0], s[1:]
// Pop back:
s, e = s[len(s)-1], s[:len(s)-1]
// Push front:
s = append([]T{e}, a...)
// Push back
s = append(s, e)
</code></pre>

<p>
</p>
</div>

<h4>About The Above Examples For More Slice Operations</h4>

<p>
In reality, the needs are varied.
For some cases, it is possible none of the above ways shown
in the above examples are the most efficient way. And sometimes,
the above ways may not satisfy some specific requirements in parctice.
So, please learn and apply elastically.
This may be the reason why Go doesn't support the more oprations
introduced above in the built-in way.
</p>

</div>

<h3>Use Maps To Simulate Sets</h3>

<p>
Go doesn't support built-in <b>set</b> types.
However, it is easy to use a map type to simulate a set type.
In practice, we often use the map type <code>map[K]struct{}</code>
to simulate a set type.
The size of the map element type <code>struct{}</code> is zero,
elements of values of such map types don't occupy memory space.
</p>

<h3>Container Releated Opetaions Are Not Synchronized Interally</h3>

<p>
Please note that, all container operations are not synchronized interally.
Without making using of any data synchronization technique,
it is okay for multiple goroutines to read a container concurrently,
but it is not okay for multiple goroutines to maniluplate a container
concurrently and at least one goroutine modifies the container.
The latter case will cause data races, even make goroutines panic.
We must synchronize the container operations manually.
Please read the articles on
<a href="concurrent-synchronization-overview.html">data synchrinizations</a>
for details.
</p>





 






