
<h1>Common Operators</h1>

<p>
Operator operations are the operations using all kinds of operators.
This article will introduce common operators in Go.
More operators will be introduced in other articles later.
</p>

<h3>About Some Descriptions In Operator Explanations</h3>

<p>
This article will only introduce arithmetic operators, bitwise operators,
comparison operators, boolean operators and string concatenation operator.
These operators are either binary operators or unary operators.
A binary operator operation takes two operands and
a unary operator operation takes only one operand.
</p>

<p>
All the operator operations introduced in this articles each returns one result.
</p>

<div>

<p>This article doesn't pursue the accuracy of some descriptions.
For example, when it says that a binary operator requires
the types of its two operands must be the same,
what it means is:</p>
<ul>
<li>
	if both of the two operands are typed values,
	then their types must be the same one,
	or one operand can be implicitly converted to the type of the other.
</li>
<li>
	if only one of the two operands is typed,
	then the other (untyped) operand must be representable as
	a value of the typed of the typed operand,
	or the values of the default type of the other (untyped) operand
	can be implicitly converted to the typed of the typed operand.
</li>
<li>
	if both of the two operands are untyped values,
	then they must be both boolean values,
	both string values or both basic numeric values.
</li>
</ul>

<p>Similarly, when it says an operator,
either a binary operator or a unary operator,
requires the type of one of its operands must be of a certain type,
what it means is:</p>
<ul>
<li>
	if the operand is typed, then its type must be,
	or can be implicitly converted to, that certain type.
</li>
<li>
	if the operand is untyped, then the untyped value must be
	representable as a value of that certain type,
	or the values of the default type of the operand
	can be implicitly converted to that certain type.
</li>
</ul>

<p>
</p>

</div>

<p class="anchor" id="constant-expression"></p>
<h3>Constant Expressions</h3>

<p>
Before introducing all kinds of operators,
we should know what are constant expressions
and a fact in the evaluations of constant expressions.
Expressions will get explained in a later article
<a href="expressions-and-statements.html">expressions and statements</a>.
At present, we just should know that most of the operations mentioned
the current article are expressions.
</p>

<p>
If all the operands involved in an expression are constants,
then this expression is called a constant expression.
All constant expressions are evaluated at compile time.
The evaluation result of a constant expression is still a constant.
</p>

<p>
Only if one operand in an expression is not a constant,
the expression is called a non-constant expression.
</p>

<h3>Arithmetic Operators</h3>

<div>
<p>
Go supports five basic binary arithmetic operators:
</p>

<table class="table table-bordered text-center" style="width:100%;">
<thead>
	<tr class="active">
	<th class="text-center" style="white-space: nowrap;">Operator</th>
	<th class="text-center">Name</th>
	<th class="text-center">Requirements For The Two Operands</th>
	</tr>
</thead>
<tbody>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">+</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			addition
		</td>
		<td style="vertical-align: middle;" class="text-left" rowspan="4">
			The two operands must be both values of the same basic numeric type.
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">-</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			subtraction
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">*</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			multiplication
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">/</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			division
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">%</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			remainder
		</td>
		<td style="vertical-align: middle;" class="text-left">
			The two operands must be both values of the same basic integer type.
		</td>
	</tr>
</tbody>
</table>

<p>
The five operators are also often called <b>sum</b>, <b>difference</b>,
<b>product</b>, <b>quotient</b> and <b>modulo</b> operators, respectively.
Go 101 will not explain how these operator operations work in detail.
</p>

<p>
Go supports six bitwise binary arithmetic operators:
</p>

<table class="table table-bordered text-center" style="width:100%;">
<thead>
	<tr class="active">
	<th class="text-center" style="white-space: nowrap;">Operator</th>
	<th class="text-center">Name</th>
	<th class="text-center">Requirements For The Two Operands And Mechanism Explanations</th>
	</tr>
</thead>
<tbody>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">&amp;</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			bitwise and
		</td>
		<td style="vertical-align: middle;" class="text-left" rowspan="4">
			<p>
			The two operands must be both values of the same integer type.
			</p>
			
			Mechanism explanations (a value with the subscript <code>2</code> is the binary literal form of the value):
			<ul>
			<li>
				<code>1100<sub>2</sub> &amp; 1010<sub>2</sub></code>
				results <code>1000<sub>2</sub></code>
			</li>
			<li>
				<code>1100<sub>2</sub> | 1010<sub>2</sub></code>
				results <code>1110<sub>2</sub></code>
			</li>
			<li>
				<code>1100<sub>2</sub> ^ 1010<sub>2</sub></code>
				results <code>0110<sub>2</sub></code>
			</li>
			<li>
				<code>1100<sub>2</sub> &^ 1010<sub>2</sub></code>
				results <code>0100<sub>2</sub></code>
			</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">|</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			bitwise or
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">^</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			bitwise xor
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">&amp;^</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			bitwise clear
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">&lt;&lt;</th>
		<td style="vertical-align: middle; white-space: nowrap;">
			bitwise left shift
		</td>
		<td style="vertical-align: middle;" class="text-left" rowspan="2">
			<p>
			The left operand must be an integer
			and the right operand must be an unsigned integer
			(or an <a href="type-system-overview.html#typed-and-untyped-values">untyped</a>
			integer constant which is representable as an <code>uint</code> value).
			</p>
			
			Mechanism explanations:
			<ul>
			<li>
				<code>1100<sub>2</sub> &lt;&lt; 3</code>
				results <code>1100000<sub>2</sub></code>
			</li>
			<li>
				<code>1100<sub>2</sub> &gt;&gt; 3</code>
				results <code>1<sub>2</sub></code>
			</li>
			</ul>
			
			<p>
			If the left operand is (or is viewed as) a signed integer,
			then the sign bit (the highest bit) in the left operand
			will be always kept in the result value. For example. if the
			left operand is an <code>int8</code> value <code>-128</code>,
			or <code>10000000<sub>2</sub></code> in the binary literal form,
			then <code>10000000<sub>2</sub> &lt;&lt; 1</code> results
			<code>11000000<sub>2</sub></code>, a.k.a., <code>-64</code>.
			</p>
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">&gt;&gt;</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			bitwise right shift
		</td>
	</tr>
</tbody>
</table>

<p>
Go also supports three unary arithmetic operators:
</p>

<table class="table table-bordered text-center" style="width:100%;">
<thead>
	<tr class="active">
	<th class="text-center" style="white-space: nowrap;">Operator</th>
	<th class="text-center">Name</th>
	<th class="text-center">Explanations</th>
	</tr>
</thead>
<tbody>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">+</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			positive
		</td>
		<td style="vertical-align: middle;" class="text-left">
			<code>+n</code> is equivalent to <code>0 + n</code>.
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">-</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			negative
		</td>
		<td style="vertical-align: middle;" class="text-left">
			<code>-n</code> is equivalent to <code>0 - n</code>.
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">^</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			bitwise complement<br/>
			(bitwise not)
		</td>
		<td style="vertical-align: middle;" class="text-left">
			<code>^n</code> is equivalent to <code>m ^ n</code>,
			where <code>m</code> is a value all of which bits are 1.
			For example,
			if the type of <code>n</code> is <code>int8</code>,
			then <code>m</code> is <code>-1</code>,
			and if the type of <code>n</code> is <code>uint8</code>,
			then <code>m</code> is <code>0xFF</code>.
		</td>
	</tr>
</tbody>
</table>

Note,
<ul>
<li>
	in many other languages,
	bitwise-complement operator is denoted as <code>~</code>.
</li>
<li>
	like many other languages,
	the addition binary operator <code>+</code> can also be used as <b>string concatenation</b> operator,
	which will be introduced below.
</li>
<li>
	like C and C++ languages,
	the multiplication binary operator <code>*</code> can also be used as <b>pointer dereference</b> operator,
	and the bitwise-and operator <code>&amp;</code> can also be used as <b>pointer address</b> operator.
	Please read <a href="pointer.html">pointers in Go</a> for details later.
</li>
<li>
	unlike Java language, Go supports unsigned integer types,
	so the unsigned shift operator <code>&gt;&gt;&gt;</code> doesn't exist in Go.
</li>
<li>
	there is no power operator in Go, please use <code>Pow</code> function
	in the <code>math</code> standard package instead.
	Code package and package import will be introduced in the next article
	<a href="packages-and-imports.html">packages and imports</a>.
</li>
<li>
	the bitwise-clear operator <code>&amp;^</code> is a unique operator in Go.
	<code>m &amp;^ n</code> is equivalent to <code>m &amp; (^n)</code>.
</li>
</ul>

<p>
</p>

Example:
<pre class="line-numbers"><code class="language-go">func main() {
	var (
		a, b float32 = 12.0, 3.14
		c, d int16   = 15, -6
		e	uint8   = 7
	)

	// The ones compile okay.
	_ = 12 + 'A' // two untyped operands (both are numeric)
	_ = 12 - a   // one untyped operand and one typed operand
	_ = a * b	// two typed operands
	_ = c % d
	_, _ = c + int16(e), uint8(c) + e
	_, _, _, _ = a / b, c / d, -100 / -9, 1.23 / 1.2
	_, _, _, _ = c | d, c & d, c ^ d, c &^ d
	_, _, _, _ = d << e, 123 >> e, e >> 3, 0xF << 0
	_, _, _, _ = -b, +c, ^e, ^-1

	// The following ones fail to compile.
	_ = a % b   // error: a and b are not integers
	_ = a | b   // error: a and b are not integers
	_ = c + e   // error: type mismatching
	_ = b >> 5  // error: b is not an integer
	_ = c >> -5 // error: -5 is not representable as uint
	_ = e << c  // error: c is not an unsigned integer
}
</code></pre>

<p>
</p>

</div>

<h4>About The Results Of Arithmetic Operator Operations</h4>

<div>

Except bitwise shift operations, the result of a binary arithmetic operator operation
<ul>
<li>
	is a typed value of the same type of the two operands
	if the two operands are both typed values of the same type.
</li>
<li>
	is a typed value of the same type of the typed operand
	if only one of the two operands is a typed value.
	In the computation, the other (untyped) value will be deduced
	as a value of the type of the typed operand.
	In other words, the untyped operand will be implicitly
	converted to the type of the typed operand.
</li>
<li>
	is still an untyped value if both of the two operands are untyped.
	The default type of the result value is one of the two default
	types and it is the one appears latter in this list: <code>int</code>,
	<code>rune</code>, <code>float64</code>, <code>complex128</code>.
	For example, if the default type of one untyped operand is <code>int</code>,
	and the other one is <code>rune</code>, then the default type of
	the result untyped value is <code>rune</code>.
</li>
</ul>

The rules for the result of a bitwise shift operator operation
is a little complicated. Firstly, the result value is always an integer value.
Whether it is typed or untyped depends on specific scenarios.
<ul>
<li>
	If the left operand is a typed value (an integer value),
	then the type of the result is the same as the type of the left operand.
</li>
<li>
	If the left operand is an untyped value (generally a constant) and the
	right operand is a constant, the left operand will be always treated as an
	integer value. If its default type is not an integer type,
	it must be representable as an untyped integer, and its default
	type will be viewed as <code>int</code>.
	The result is also an untyped value and its default type is the same as the left operand.
</li>
<li>
	If the left operand is an untyped value and the right operand
	is a non-constant (unsigned) integer, the left operand will be first
	converted to the type it would assume if the bitwise shift operator
	operation were replaced by its left operand alone.
	The result is a typed value whose type is the assumed type.
</li>
</ul>

Example:
<pre class="line-numbers"><code class="language-go">func main() {
	const X, Y, Z = 2, 'A', 3i // three untyped values. 
							   // Default types: int, rune, complex64.
	
	var a, b int = X, Y // two typed values.

	d := X + Y // the type of d is the default type of Y: rune (int32).
	e := Y - a // the type of e is the type of a: int.
	f := a * b // the type of f is the types of a and b: int.
	g := Z * Y // the type of g is the default type of Z: complex64.

	println(X, Y, Z)	// 2 65 (+0.000000e+000+3.000000e+000i)
	println(d, e, f, g) // 67 63 130 (+0.000000e+000+1.950000e+002i)
}
</code></pre>

<p>
</p>

Another example (bitwise shift operations):
<pre class="line-numbers"><code class="language-go">const N = 2
const A = 3.0 << N	     // A == 6, its default type is int.
const B = int8(3.0) << N // B == 6, it is typed and its type is int8.

var m = uint(32)
// The following three lines are equivalent to each other.
var x int64 = 1 << m  // the type of 1 is deduced as int64, not int.
var y = int64(1 << m) // the type of 1 is deduced as int64, not int.
var z = int64(1) << m

// The following lines fail to compile.
/*
var _ = 3.0 << m // error: shift of type float64
const _ = 1 << B // error: the right operand must be unsigned.
*/
</code></pre>

<p>
The last rule for bitwise shift operator operation is to avoid some operations
returning different results on different architectures.
For example, the bitwise operation at line <i>8</i> will return different results
between 32-bit architectures and 64-bit architectures
if the operand <code>1</code> is deduced as
<code>int</code> instead of <code>int64</code>,
which may produce some bugs hard to detect.
</p>

One intresting consequence of the last rule for bitwise shift operator operation
is shown in the following code snippet:

<pre class="line-numbers"><code class="language-go">const n = uint(2)
var m = uint(2)

// The following two lines compile okay.
var _ float64 = 1 << n
var _ = float64(1 << n)

// The following two lines fail to compile.
var _ float64 = 1 << m
var _ = float64(1 << m)
</code></pre>

The reason of the last two lines failing to compile is they are both
equivalent to the following line:

<pre class="line-numbers"><code class="language-go">var _ = float64(1) << m
</code></pre>

</div>

<h4>About Overflows</h4>

<div>

<p>
Overflows are not allowed for typed constant values
but are allowed for non-constant and untyped constant values,
either the values are intermediate or final results.
Overflows will be truncated (or wrapped around) for non-constant values,
but overflows (for default types) on untyped constant value
will not be truncated (or wrapped around).
</p>

Example:
<pre class="line-numbers"><code class="language-go">// Results are non-constants.
var a, b uint8 = 255, 1
var c = a + b  // okay: higher overflowed bits are truncated. c == 0
var d = a << b // okay: higher overflowed bits are truncated. d == 254

// Results are untyped constants.
const X = 0x1FFFFFFFF * 0x1FFFFFFFF // okay, though X overflows int.
const R = 'a' + 0x7FFFFFFF		    // okay, though R overflows rune.

// Operation results or conversion results are typed values.
// These lines all fail to compile.
var e = X				 // error: untyped constant X overflows int.
var h = R				 // error: constant 2147483744 overflows rune.
const Y = 128 - int8(1)  // error: 128 overflows int8
const Z = uint8(255) + 1 // error: the result 256 overflow uint8.
</code></pre>

<p>
</p>

</div>

<h4>About Integer Division And Remainder Operations</h4>

<div>

<p>
Assume <code>x</code> and <code>y</code> are two operands of the same integer type,
the integer quotient <code>q</code> (<code>= x / y</code>)
and remainder <code>r</code> (<code>= x % y</code>)
satisfy <code>x == q*y + r</code>, where <code>|r| < |y|</code>.
If <code>r</code> is not zero, its sign is the same as <code>x</code>
(the dividend).
The result of <code>x / y</code> is truncated towards zero.
</p>

<p>
If the divisor <code>y</code> is a constant, it must not be zero.
If the divisor is zero at run time and it is an integer,
a run-time panic occurs.
Panics are like exceptions in some other languages.
We can learn more about panics in <a href="control-flows-more.html">this article</a>.
</p>

Example:
<pre class="line-numbers"><code class="language-go">println( 5/3,   5%3)  // 1 2
println( 5/-3,  5%-3) // -1 2
println(-5/3,  -5%3)  // -1 -2
println(-5/-3, -5%-3) // 1 -2

println(5.0 / 3.0)	 // 1.666667
println((1-1i)/(1+1i)) // -1i

var a, b = 1.0, 0.0
println(a/b, b/b) // +Inf NaN

_ = int(a)/int(b) // compile okay but panic at run time.

// The following two lines fail to compile.
println(1.0/0.0) // error: division by zero
println(0.0/0.0) // error: division by zero
</code></pre>

<p>
</p>

</div>

<h4>Using <code>op=</code> For Binary Arithmetic Operators</h4>

<div>

<p>
For a binary arithmetic operator <code>op</code>, <code>x = x op y</code>
can be shortened to <code>x op= y</code>.
In the short form, <code>x</code> will be only evaluated once.
</p>

Example:
<pre class="line-numbers"><code class="language-go">var a, b int8 = 3, 5
a += b
println(a) // 8
a *= a
println(a) // 64
a /= b
println(a) // 12
a %= b
println(a) // 2
b <<= uint(a)
println(b) // 20
</code></pre>

</div>

<h4>The Increment <code>++</code> And Decrement <code>--</code> Operators</h4>

<div>
<p>
Like many other popular languages, Go also supports
the increment <code>++</code> and decrement <code>--</code> operators.
However, operations using the two operators don't return any results,
so such operations can not be used as
<a href="expressions-and-statements.html">expressions</a>.
The only operand involved in such an operation must be a numeric value,
the numeric value must not be a constant, and the <code>++</code> or
<code>--</code> operator must follow the operand.
</p>

Example:
<pre class="line-numbers"><code class="language-go">package main

func main() {
	a, b, c := 12, 1.2, 1+2i
	a++ // okay
	b-- // okay
	c++ // okay
	
	// The following three lines fail to compile.
	/*
	_ = a++
	_ = b--
	_ = c++
	++a
	--b
	++c
	*/
}
</code></pre>

</div>

<h3>String Concatenation Operator</h3>

<div>

As above has mentioned, the addition operator can also be used as
string concatenation.

<table class="table table-bordered text-center" style="width:100%;">
<thead>
	<tr class="active">
	<th class="text-center" style="white-space: nowrap;">Operator</th>
	<th class="text-center">Name</th>
	<th class="text-center">Requirements For The Two Operands</th>
	</tr>
</thead>
<tbody>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">+</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			string concatenation
		</td>
		<td style="vertical-align: middle;" class="text-left">
			The two operands must be both values of the same string type.
		</td>
	</tr>
</tbody>
</table>

<p>
The <code>op=</code> form also applies for the string concatenation operator.
</p>

Example:
<pre class="line-numbers"><code class="language-go">println("Go" + "lang") // Golang
var a = "Go"
a += "lang"
println(a) // Golang
</code></pre>

<p>
</p>

<p>
If one of the two operands of a string concatenation operation
is a typed string, then the type of the result
string is the same as the type of the typed string.
If both the of the two operands are untyped (constant) strings,
the result is also an untyped string value.
</p>

</div>

<h3>Boolean Operators</h3>

<div>
<p>
Go supports two boolean binary operators and one boolean unary operator:
</p>

<table class="table table-bordered text-center" style="width:100%;">
<thead>
	<tr class="active">
	<th class="text-center" style="white-space: nowrap;">Operator</th>
	<th class="text-center">Name</th>
	<th class="text-center">Requirements For Operand(s)</th>
	</tr>
</thead>
<tbody>
	<tr>
		<th scope="row" style="vertical-align: middle;" class="text-center" style="white-space: nowrap;">&amp;&amp;</th>
		<td style="vertical-align: middle;" class="text-center">
			boolean and (binary)
		</td>
		<td style="vertical-align: middle;" class="text-left" rowspan="2">
			The two operands must be both values of the same boolean type.
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle;" class="text-center" style="white-space: nowrap;">||</th>
		<td style="vertical-align: middle;" class="text-center">
			boolean or (binary)
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle;" class="text-center" style="white-space: nowrap;">!</th>
		<td style="vertical-align: middle;" class="text-center">
			boolean not (unary)
		</td>
		<td style="vertical-align: middle;" class="text-left">
			The type of the only operand must be a boolean type.
		</td>
	</tr>
</tbody>
</table>

<p>
We can use the <code>!=</code> operator introduced in the next sub-section as the <b>boolean xor</b> operator.
</p>

Mechanism explanations:
<pre><code class="language-go">// x	  y	 x && y	 x || y	!x	 !y
true	true	true	   true	 false  false
true	false   false	  true	 false  true
false   true	false	  true	 true   false
false   false   false	  false	true   true
</code></pre>

<p>
If one of the two operands is a typed boolean, then the type of the result
boolean is the same as the type of the typed boolean.
If both the of the two operands are untyped booleans,
the result is also an untyped boolean value.
</p>

</div>

<h3>Comparison Operators</h3>

<div>
<p>
Go supports six comparison binary operators:
</p>

<table class="table table-bordered text-center" style="width:100%;">
<thead>
	<tr class="active">
	<th class="text-center" style="white-space: nowrap;">Operator</th>
	<th class="text-center">Name</th>
	<th class="text-center">Requirements For The Two Operands</th>
	</tr>
</thead>
<tbody>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">==</th>
		<td style="vertical-align: middle; white-space: nowrap;">
			equal to
		</td>
		<td style="vertical-align: middle;" class="text-left" rowspan="2">
			<p>
			If the two operands are both typed, then their types must be the same one,
			or one operand can be implicitly converted to the type of the other operand.
			</p>

			<p>
			If only one operand is typed, then the other untyped operand must be able to
			be implicitly converted to the type of the typed operand.
			</p>

			<p>
			If the two operands are both untyped, the they must be both untyped booleans,
			both untyped strings or both untyped numeric values.
			</p>
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle;" class="text-center">!=</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			not equal to
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">&lt;</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			less than
		</td>
		<td style="vertical-align: middle;" class="text-left" rowspan="4">
			The two operands must be both values of the same integer type,
			floating-point type or string type.
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">&lt;=</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			less than or equal to
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">&gt;</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			larger than
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">&gt;=</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			larger than or equal to
		</td>
	</tr>
</tbody>
</table>

<p>
The type of the result of any comparison operation is always an
untyped boolean value.
If both of the two operands of a comparison operation are constant,
the result is also a constant (boolean) value.
</p>

<p>
Later, if we say two values are comparable, we mean they can be compared
with the <code>==</code> and <code>!=</code> operators.
We will learn that values of which types are not comparable later.
Values of basic types are all comparable.
</p>

<p>
Please note that, not all real numbers can be accurately represented
in memory, so comparing two floating-point (or complex) values may
be not reliable. We should check whether or not the absolution of
the difference of two floating-point values is smaller than a small threshold
to judge whether or not the two floating-point values are equal.
</p>

</div>

<h3>Operator Precedences</h3>

<div>

<p>
The operator precedences may be also some different to other languages.
Here are the operator precedences in Go. Top ones have higher precedences.
The precedences of operators in the same line are same.
Like many other languages, <code>()</code> can be used to promote precedences.
</p>

<pre class="line-numbers"><code class="language-go">*   /   %   <<  >>  &   &^
+   -   |   ^
==  !=  <   <=  >   >=
&&
||
</code></pre>

<p>
</p>

<p>
One obvious difference to some other popular languages
is that the precedences of <code>&lt;&lt;</code> and
<code>&gt;&gt;</code> are higher than <code>+</code> and <code>-</code> in Go.
</p>

</div>

<p class="anchor" id="constant-expression-more"></p>
<h3>More About Constant Expressions</h3>

<div>

The following declared variable will be initialized as <code>2.2</code>
instead of <code>2.7</code>.
The reason is the division operation has a higher precedence than
the addition operation, and in the division operation,
both <code>3</code> and <code>2</code> are viewed as integers.
The evaluation result of <code>3/2</code> is <code>1</code>.

<pre class="line-numbers"><code class="language-go">var x = 1.2 + 3/2
</code></pre>

<p>
</p>

The two named constants declared in the following program are not equal.
In the first declaration, both <code>3</code> and <code>2</code> are
viewed as integers, however, they are both viewed as floating-point numbers
in the second declaration.

<pre class="line-numbers"><code class="language-go">package main

const x = 3/2*0.1
const y = 0.1*3/2

func main() {
	println(x) // +1.000000e-001
	println(y) // +1.500000e-001
}
</code></pre>

<p>
</p>

</div>

<h3>More Operators</h3>

<div>
<p>
Same as C/C++,
there are two pointer related operators, <code>*</code> and <code>&amp;</code>.
Yes the same operator symbols as the multiplication and bitwise-and operators.
<code>&amp;</code> is used to take the address of an addressable value,
and <code>*</code> is used to deference a pointer value.
Unlike C/C++, in Go, values of pointer types don't support arithmetic operations.
For more details, please read <a href="pointer.html">pointers in Go</a> later.
</p>

<p>
There are some other operators in Go.
They will be introduced and explained in other Go 101 articles.
</p>

</div>
