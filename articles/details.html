<h1>Go Details 101</h1>

<div>
<p>
This article will list all kinds of details in Go.
Some of these details are shown in other Go 101 articles,
some are shown in the following sections.
</p>

<ul>
<li>
	Code package related details:
	<ul>
	<li>
		<a href="#import-package-multiple-times">A package can be imported more than once in a source file.</a>
	</li>
	<li>
		<a href="#force-import-path">The comment <code>// import "x.y.z.mypkg"</code> following <code>package mypkg</code> is meaningful for the standard Go compiler.</a>
	</li>
	</ul>
</li>
<li>
	Control flow related details:
	<ul>
	<li>
		<a href="control-flows.html#default-branch-placement">The <code>default</code> branch in <code>switch</code> and <code>select</code> blocks can be put before all case branches, after all case branches, or between case branches.</a>
	</li>
	<li>
		<a href="control-flows-more.html#defer-modify-resutls">Nested deferred function calls can modify return result values of nesting functions.</a>
	</li>
	<li>
		<a href="#different-loops">For a slice <code>s</code>, the loop <code>for i = range s {...}</code> is not equivalent to the loop <code>for i = 0; i < len(s); i++ {...}</code>.</a>
	</li>
	<li>
		<a href="#os-exit-runtime-goexit">Exit a program with a <code>os.Exit</code> function call and exit a goroutine with a <code>runtime.Goexit</code> function call</a>
	</li>
	</ul>
</li>
<li>
	Pointer related details:
	<ul>
	<li>
		<a href="pointer.html#restrictions">For a numeric value pointer <code>p</code>, expression <code>*p++</code> is equivalent to <code>(*p)++</code>. If <code>p</code> is not a numeric value pointer, <code>*p++</code> doesn't compile.</a>
	</li>
	<li>
		<a href="value-conversions-assignments-and-comparisons.html#conversion-rule-underlying-types">Values of two named pointer types can be converted to each other if the base types of the two types are identical. The underlying types of the two pointer types can be different.</a>
	</li>
	<li>
		<a href="#addresses-of-zeor-sized-values">Addresses of different zero-sized values may be equal, or not.</a>
	</li>
	<li>
		<a href="#self-based-pointer-type">The base type of a pointer type may be the pointer type itself.</a>
	</li>
	<li>
		<a href="#pointer-selector-shorthands">A detail about selector shorthands.</a>
	</li>
	</ul>
</li>
<li>
	Container related details:
	<ul>
	<li>
		<a href="container.html#composite-literal-simplification">Sometimes, nested composite Literals can be simplified.</a>
	</li>
	<li>
		<a href="container.html#use-pointer-as-array">In some scenarios, it is ok to use array pointers as arrays.</a>
	</li>
	<li>
		<a href="container.html#element-accessment">Retreiving elements from nil maps will not panic. The result is a zero element value.</a>
	</li>
	<li>
		<a href="container.html#element-addition-deletion">Deleting an entry from a nil map will not panic. It is a no-op.</a>
	</li>
	<li>
		<a href="container.html#element-addition-deletion">The result slice of an <code>append</code> function call may share some elements with the original slice, or not.</a>
	</li>
	<li>
		<a href="container.html#subslice">The length of a subslice may be larger than the base slice the subslice is derived from.</a>
	</li>
	<li>
		<a href="container.html#subslice">Deriving a subslice from a nil slice is ok only if all the indexes used in the subslice expression are zero. The result subslice is also a nil slice.</a>
	</li>
	<li>
		<a href="container.html#modify-slice-length-and-capacity">The length and capacity of a slice can be modified seperately.</a>
	</li>
	<li>
		<a href="container.html#value-literals"">The indexes in slice and array composite literals must be non-negative integer constants.</a>
	</li>
	<li>
		<a href="#array-slice-element-addressability">Elements of unaddressable arrays are also unaddressable, but elements of unaddressable slices are always addressable.</a>
	</li>
	<li>
		<a href="#array-slice-derivable">It is ok to derive subslices from unaddressable slices, but not ok from unaddressable arrays. It is ok to take element addresses for unaddressable slices, but not ok for unaddressable arrays.</a>
	</li>
	<li>
		<a href="#nan-as-map-keys">Putting elements with NaN as key to a map is like putting the elements in a black hole.</a>
	</li>
	<li>
		<a href="#constent-map-keys">Constant key values in a container composite literal can't be duplicated.</a>
	</li>
	<li>
		<a href="container.html#iteration">In a <code>for-range</code> loop code block, any iteration variable can be ignored or omitted.</a>
	</li>
	<li>
		<a href="container.html#iteration">In a for-range loop, the iterator variable(s) and the ranged container are all value copies.</a>
	</li>
	<li>
		<a href="container.html#iteration">Ranging over a nil maps or a nil slices is ok, it is a no-op.</a>
	</li>
	<li>
		<a href="container.html#use-pointer-as-array">Range over a nil array pointer is ok if the second iteration variable is ignored or omitted.</a>
	</li>
	<li>
		<a href="container.html#memclr">There is an optimization made by the standard Go compiler to reset container elements as zero values.</a>
	</li>
	<li>
		<a href="#capacity-of-slice-from-string">The capacity of the result slice of a conversion from a string to byte/rune slice may be larger than the length of the result slice.</a>
	</li>
	</ul>
</li>
<li>
	String related details:
	<ul>
	<li>
		<a href="string.html#comparison">The time complexity of comparing two equal strings may be <code><i>O</i>(1)</code> or <code><i>O</i>(n)</code>.</a>
	</li>
	<li>
		<a href="string.html#use-string-as-byte-slice">If the first argument of a built-in function <code>copy</code> or <code>append</code> call is a byte slice, then the second argument can be a string followed by <code>...</code>.</a>
	</li>
	</ul>
</li>
<li>
	Function and method related details:
	<ul>
	<li>
		<a href="function.html#call-as-expression">A multi-result function call can't mix with other expessions when the call is used as the sources in an assignment or the arguments of another function call.</a>
	</li>
	<li>
		<a href="function.html#compile-time-evaluated-calls">Some function calls are evaluated at compile time.</a>
	</li>
	<li>
		<a href="method.html#method-as-function">Each method corresponds to an implicit function.</a>
	</li>
	</ul>
</li>
<li>
	Interface related details:
	<ul>
	<li>
		<a href="interface.html#comparison">Comparing an interface value with itself might cause a panic.</a>
	</li>
	<li>
		<a href="interface.html#type-assertion">Type assertions can be used to convert a value of an interface type to another interface type, even if the former interface type doesn't implemented the latter one.</a>
	</li>
	<li>
		<a href="exceptions.html#behaviors-on-missing-optional-result">Whether or not the second optional result of a type assertion is present will affect the behavior of the type assertion.</a>
	</li>
	<li>
		<a href="#interface-comparison-complexity">For the standard Go compiler, the time complexity of comparing two equal interface values may be <code><i>O</i>(1)</code> or <code><i>O</i>(n)</code>.</a>
	</li>
	<li>
		<a href="#interface-copy-complexity">For the standard Go compiler, the time complexity of copying an interface value is <code><i>O</i>(1)</code>.</a>
	</li>
	<li>
		<a href="#errors-new-different-returns">Two <code>error</code> values returned by two <code>errors.New</code> calls with the same argument are not equal.</a>
	</li>
	</ul>
</li>
<li>
	Channel related details:
	<ul>
	<li>
		<a href="channel.html#operations">Receive-only channels can't be closed.</a>
	</li>
	<li>
		<a href="channel.html#simple-rule-summary">Sending a value to a closed channel is viewed as a non-blocking operation, and this operation causes a panic.</a>
	</li>
	</ul>
</li>
<li>
	More type and value related details:
	<ul>
	<li>
		<a href="value-part.html">In Go, a value of some types may be composed of more than one parts.</a>
	</li>
	<li>
		<a href="type-system-overview.html#type-definition">Types can be declared within function bodies.</a>
	</li>
	<li>
		<a href="#naa-inf">NaN != NaN, Inf == Inf.</a>
	</li>
	<li>
		<a href="nil.html#sizes">The sizes of nil values of different types may be different.</a>
	</li>
	<li>
		<a href="blocks-and-scopes.html#weird-shadowing"><code>nil</code>, <code>iota</code>, <code>true</code>, <code>false</code> and built-in types are not keywords. They are just predeclared identifiers.</a>
	</li>
	<li>
		<a href="unofficial-faq.html#final-zero-size-field">For the standard compiler, zero-sized fields in a struct may be treated as one-byte-sized value.</a>
	</li>
	<li>
		<a href="#non-exported-names-from-different-packages">Non-exported method names and struct field names from different packages are viewed as diffferent names.</a>
	</li>
	<li>
		<a href="blocks-and-scopes.html#scope-difference-detail"><code>type T *T</code> is a valid type definition</a>
	</li>
	</ul>
</li>
<li>
	Miscellanies:
	<ul>
	<li>
		<a href="#sometimes-parentheses-are-required">Parentheses are required in several rare scenarios to make code compile okay.</a>
	</li>
	<li>
		<a href="#main-entry-function-missing">A program doesn't need a <code>main</code> entry function to run.</a>
	</li>
	<li>
		<a href="line-break-rules.html#commas">The extra last <code>,</code> in an item list (such parameter/argument/result lists and element lists in composite literals) never do harm.</a>
	</li>
	</ul>
</li>
<li>
	Standard packages related:
	<ul>
	<li>
		<a href="reflection.html#deep-equal">The results of <code>reflect.DeepEqual(x, y)</code> and <code>x == y</code> may be different.</a>
	</li>
	<li>
		<a href="#check-file-existent">We should use <code>os.IsNotExist(err)</code> instead of <code>err == os.ErrNotExist</code> to check whether or not a file exists.</a>
	</li>
	<li>
		<a href="#boolean-flag">The <code>flag</code> standard package treats boolean command flags differently than integer and string flags.</a>
	</li>
	<li>
		<a href="#printf-positional-arguments"><code>[Sp|Fp|P]rintf</code> functions support positional arguments.</a>
	</li>
	</ul>
</li>
</div>

<p class="anchor" id="import-package-multiple-times"></p>
<h3>A package can be imported more than once in a source file</h3>

<div>
<p>
A Go source file can imports the same package multiple times,
but the import names must be different.
These same-pacakge imports reference the same package instance.
</p>

For example:
<pre class="line-numbers"><code class="language-go">package main

import "fmt"
import "io"
import inout "io"

func main() {
	fmt.Println(&inout.EOF == &io.EOF) // true
}
</code></pre>
</div>

<p class="anchor" id="array-slice-element-addressability"></p>
<h3>Elements of unaddressable arrays are also unaddressable, but elements of unaddressable slices are always addressable</h3>

<div>
<p>
The reason is the elements of an array value and the array will be stored
in the same memory block when the array is stored in memory.
But <a href="unofficial-faq.html#slice-elements-always-addressable">the
situation is different for slices</a>.
</p>

An example:

<pre class="line-numbers"><code class="language-go">package main

func main() {
	// Container composite literals and map elements are all unaddressable.
	
	// Take container element addresses.
	_ = &[]int{1}[0] // ok
	_ = &[5]int{}[0] // error: cannot take the address of [5]int literal[0]
	_ = &(&[5]int{})[0] // ok
	_ = &(*&[5]int{})[0] // ok
	
	// Modify container element values.
	map[int]int{}[1] = 9
	[]int{1,2,3}[1] = 9
	[3]int{1,2,3}[1] = 9 // error: cannot assign to [3]int literal[1]
	(&[3]int{1,2,3})[1] = 9
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="array-slice-derivable"></p>
<h3>
It is ok to derive subslices from unaddressable slices, but not ok from unaddressable arrays.
It is ok to take element addresses for unaddressable slices, but not ok for unaddressable arrays.
</h3>

<div>
<p>
The reason is the same as the last detail.
</p>

An example:
<pre class="line-numbers"><code class="language-go">package main

func main() {
	// Literal values and map elements are unaddressable in Go.
	
	// The following lines fail to compile.
	/*
	_ = [...]int{6, 7, 8, 9}[1:3]  // error: slice of unaddressable value
	_ = &([...]int{6, 7, 8, 9}[0]) // error: cannot take element address
	var ma = map[string][4]int{"abc": {0, 1, 2, 3}}
	_ = ma["abc"][1:3]  // error: slice of unaddressable value
	_ = &(ma["abc"][0]) // error: cannot take element address
	*/
	
	// The following lines compile okay.
	_ = []int{6, 7, 8, 9}[1:3]
	_ = &([]int{6, 7, 8, 9}[0])
	var ms = map[string][]int{"abc": {0, 1, 2, 3}}
	_ = ms["abc"][1:3]
	_ = &(ms["abc"][0])
}
</code></pre>
<p>
</p>
</div>

<p class="anchor" id="naa-inf"></p>
<h3>NaN != NaN, Inf == Inf</h3>

<div>
This follows IEEE-754 standard and is consistent with most other programming languages:
<pre class="line-numbers"><code class="language-go">package main

import "fmt"
import "math"

func main() {
	var a = math.Sqrt(-1.0)
	fmt.Println(a)      // NaN
	fmt.Println(a == a) // false
	
	var x = 0.0
	var y1, z1 = 1 / x, 2 / x
	var y2, z2 = -1 / x, -2 / x
	fmt.Println(y1, z1, y1 == z1) // +Inf +Inf true
	fmt.Println(y2, z2, y2 == z2) // +Inf +Inf true
}
</code></pre>
<p>
</p>
</div>

<p class="anchor" id="nan-as-map-keys"></p>
<h3>Putting elements with NaN as key to a map is like putting the elements in a black hole</h3>

<div>
This reason is <code>NaN != NaN</code> (see the above detail).
The elements with <code>NaN</code> as key can only be found out
in a <code>for-range</code> loop.

<pre class="line-numbers"><code class="language-go">package main

import "fmt"
import "math"

func main() {
	var a = math.NaN()
	fmt.Println(a)      // NaN
	
	var m = map[float64]int{}
	m[a] = 123
	v, present := m[a]
	fmt.Println(v, present) // 0 false
	m[a] = 789
	v, present = m[a]
	fmt.Println(v, present) // 0 false
	
	fmt.Println(m) // map[NaN:&lt;nil&gt; NaN:&lt;nil&gt;]
	delete(m, a) // no-op
	fmt.Println(m) // map[NaN:&lt;nil&gt; NaN:&lt;nil&gt;]
	
	for k, v := range m {
		fmt.Println(k, v)
	}
	// the above loop outputs:
	// NaN 123
	// NaN 789
}
</code></pre>
<p>
</p>
</div>

<p class="anchor" id="interface-comparison-complexity"></p>
<h3>For the standard Go compiler, the time complexity of comparing two equal interface values may be <code><i>O</i>(1)</code> or <code><i>O</i>(n)</code></h3>

<div>
The time complexity depends on whether or not the direct parts
of the two equal interfaces both reference the undrelying value.
Please read the article <a href="value-part.html#interface-structure">value parts</a> for detail.

<pre class="line-numbers"><code class="language-go">package main

import "fmt"
import "time"

func main() {
	bigarr := [1 << 20]int{}
	
	type I interface{}
	
	// i0, i1 and i2 are three equal interfaces.
	var i0 I = bigarr // the dynamic value of i0 is a copy of bigarr.
	var i1 I = bigarr // the dynamic value of i1 is also a copy of bigarr.
	                  // Note, the dynamic values of i0 and i1 are
	                  // two different copies of bigarr.
	var i2 I = i1 // i2 shares the same dynamic value copy with i1.

	startTime := time.Now()
	_ = i0 == i1
	duration := time.Since(startTime)
	fmt.Println("duration for (i0 == i1):", duration)
	
	startTime = time.Now()
	_ = i1 == i2
	duration = time.Since(startTime)
	fmt.Println("duration for (i1 == i2):", duration)
}
/*
The output (1ms == 1,000,000ns):
duration for (i0 == i1): 1.381337ms
duration for (i1 == i2): 609ns
*/
</code></pre>
<p>
1ms is 1000000ns!
</p>
</div>

<p class="anchor" id="interface-copy-complexity"></p>
<h3>About the time complexity of copying a non-nil interface value</h3>

<!---
https://github.com/golang/go/issues/17181
-->

<p>
The <a href="https://golang.org/doc/faq#pass_by_value">official Go FAQ</a>
says <b><i>copying an interface value makes a copy of the thing stored in the interface value.</i></b>.
The article <a href="interface.html#boxing">interfaces in Go</a> mentions that,
for the standard Go compiler, the time complexity of copying an interface value
is <code><i>O</i>(1)</code>.
But the the sizes of different dynamic values stored in interface values may
be different, why isn't the complexity <code><i>O</i>(n)</code>?
</p>

<p>
The reason is the dynamic values of interface values are all inmutable,
so the standard Go compiler makes an optimization here.
As the article <a href="value-part.html#interface-structure">value parts</a>
has explained, an non-nil interface value has an underlying part and
the direct part of the interface value stores a pointer which
references the underlying part. When the interface value is copied,
only its direct part is copied. For the standard Go compiler,
the sizes of the direct parts of all interface values are the same.
</p>

<p class="anchor" id="constent-map-keys"></p>
<h3>Constant key values in a container composite literal can't be duplicated</h3>

<div>
Duplicated non-constant keys are allowed. For example:

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	const N = 123
	var n = N
	
	var m = map[int]string {
		N: "abc",
		// N: "xyz", // error: duplicate key N in map literal
		n: "hello", // ok
		n: "bye", // ok
	}
	
	fmt.Println(m[N])
}
</code></pre>

<p>
Please note, Go specification doesn't specifies the element initilization
order in a composite literal. So the above program may print <code>abc</code>,
<code>hello</code> or <code>bye</code>, depending on compilers and compiler versions.
</p>
</div>

<p class="anchor" id="addresses-of-zeor-sized-values"></p>
<h3>Addresses of different zero-sized values may be equal, or not</h3>
<!--
https://github.com/golang/go/issues/12726
-->

<div>
Whether or not the addresses of two zero-sized values are equal
is compiler and compiler version dependent.

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	a := struct{}{}
	b := struct{}{}
	x := struct{}{}
	y := struct{}{}
	m := [10]struct{}{}
	n := [10]struct{}{}
	o := [10]struct{}{}
	p := [10]struct{}{}
	
	fmt.Println(&x, &y, &o, &p)
	
	// For the standard Go compiler (1.10),
	// x, y, o and p escape to heap,
	// but a, b, m and n are allocated on stack.
	
	fmt.Println(&a == &b) // false
	fmt.Println(&x == &y) // true
	fmt.Println(&a == &x) // false
	
	fmt.Println(&m == &n) // false
	fmt.Println(&o == &p) // true
	fmt.Println(&n == &p) // false
}
</code></pre>

<p>
The outputs indicated in the above code are for the standard Go compiler 1.10.
</p>
</div>

<p class="anchor" id="check-file-existent"></p>
<h3>We should use <code>os.IsNotExist(err)</code> instead of <code>err == os.ErrNotExist</code> to check whether or not a file exists</h3>

<div>

Using <code>err == os.ErrNotExist</code> may miss errors.

<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
	"os"
)

func main() {
	_, err := os.Stat("a-nonexistent-file.abcxyz")
	fmt.Println(os.IsNotExist(err))    // true
	fmt.Println(err == os.ErrNotExist) // false
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="self-based-pointer-type"></p>
<h3>The base type of a pointer type may be the pointer type itself</h3>

<div>

An example:

<pre class="line-numbers"><code class="language-go">package main

func main() {
	type P *P
	var p P
	p = &p
	p = **************p
}
</code></pre>

<p>
</p>

Similarly, 
<ul>
<li>
	the element type of a slice type can be the slice type itself,
</li>
<li>
	the element type of a map type can be the map type itself,
</li>
<li>
	the element type of a channel type can be the channel type itself,
</li>
<li>
	and the argument and result types of a function type can be the function type itself.
</li>
</ul>

<pre class="line-numbers"><code class="language-go">package main

func main() {
	type S []S
	type M map[string]M
	type C chan C
	type F func(F) F
	
	s := S{0:nil}
	s[0] = s
	m := M{"Go": nil}
	m["Go"] = m
	c := make(C, 3)
	c <- c; c <- c; c <- c
	var f F
	f = func(F)F {return f}
	
	_ = s[0][0][0][0][0][0][0][0]
	_ = m["Go"]["Go"]["Go"]["Go"]
	<-<-<-c
	f(f(f(f(f))))
}
</code></pre>

<p>
</p>

</div>

<p class="anchor" id="sometimes-parentheses-are-required"></p>
<h3>Parentheses are required in several rare scenarios to make code compile okay</h3>

<div>
For example:

<pre class="line-numbers"><code class="language-go">package main

type T struct{x, y int}

func main() {
	// Each of the following three lines makes code fail to compile.
	// Some "{}" confuse compilers.
	/*
	if T{} == T{123, 789} {}
	if T{} == (T{123, 789}) {}
	if (T{}) == T{123, 789} {}
	*/
	
	// We must add parentheses like the following two lines to
	// make code compile okay.
	if (T{} == T{123, 789}) {}
	if (T{}) == (T{123, 789}) {}
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="force-import-path"></p>
<h3>The comment <code>// import "x.y.z.mypkg"</code> following <code>package mypkg</code> is meaningful for the standard Go compiler</h3>

<div>
For example, when the source files importing this package are compiled by the standard Go compiler,
the import path of the following package must be <code>"x.y.z.mypkg"</code>.

<pre class="line-numbers"><code class="language-go">package mypkg // import "x.y.z.mypkg"
...
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="different-loops"></p>
<h3>For a slice <code>s</code>, the loop <code>for i = range s {...}</code> is not equivalent to the loop <code>for i = 0; i < len(s); i++ {...}</code></h3>

<div>
The respective final values of the iteration variable <Code>i</code>
may be different for the two loops.

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

var i int

func fa(s []int, n int) int {
	i = n
	for i = 0; i < len(s); i++ {}
	return i
}

func fb(s []int, n int) int {
	i = n
	for i = range s {}
	return i
}

func main() {
	s := []int{2, 3, 5, 7, 11, 13}
	fmt.Println(fa(s, -1), fb(s, -1)) // 6 5
	s = nil
	fmt.Println(fa(s, -1), fb(s, -1)) // 0 -1
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="main-entry-function-missing"></p>
<h3>A program doesn't need a <code>main</code> entry function to run</h3>

<div>
The following program runs well, at least for the standard Go compiler 1.10.
(It may be not runnable since 1.11. Please read <a href="https://github.com/golang/go/issues/21256">issue#21256</a> for details.)

<pre class="line-numbers"><code class="language-go">package main

import (
    "fmt"
    "time"
)

func init() {
	for {
		time.Sleep(time.Second)
		fmt.Println("hi")
	}
}

var main int
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="pointer-selector-shorthands"></p>
<h3>A detail about selector shorthands</h3>

<div>

<p>
<p>
For a pointer value, which type is either defined or not,
if the base type of its (pointer) type is a struct type,
then the pointer value can access the <b>fields</b> of
the struct value it references.
However, if the type of the pointer value is a defined type,
the value can not access the methods of the value its references.
</p>

<pre class="line-numbers"><code class="language-go">package main

type T struct {
	x int
}
func (T) m(){} // T has one method.

type P *T  // a defined one-level pointer type.
type PP *P // a defined two-level pointer type.

func main() {
	var t T
	var tp = &t
	var tpp = &tp
	var p P = tp
	var pp PP = &p
	tp.x = 12  // okay
	p.x = 34   // okay
	pp.x = 56  // error: type PP has no field or method x
	tpp.x = 78 // error: type **T has no field or method x)
	
	tp.m()  // okay. Type *T also has a "m" method.
	p.m()   // error: type P has no field or method m
	pp.m()  // error: type PP has no field or method m
	tpp.m() // error: type **T has no field or method m
}
</code></pre>
<p>
</p>
</div>

<p class="anchor" id="non-exported-names-from-different-packages"></p>
<h3>Non-exported method names and struct field names from different packages are viewed as diffferent names</h3>

<div>
For example, if the following types are declared in package <code>foo</code>:

<pre class="line-numbers"><code class="language-go">package foo

type I = interface {
	about() string
}

type S struct {
	a string
}

func (s S) about() string {
	return s.a
}
</code></pre>

and the following types are declared in package <code>bar</code>:

<pre class="line-numbers"><code class="language-go">package bar

type I = interface {
	about() string
}

type S struct {
	a string
}

func (s S) about() string {
	return s.a
}
</code></pre>

then, 
<ul>
<li>
	values of the two respective types <code>S</code> from the two packages
	can't be converted to each other.
</li>
<li>
	the two respective interface types <code>S</code> from the two packages
	denote two distinct method sets.
</li>
<li>
	type <code>foo.S</code> doesn't implement the interface type <code>bar.I</code>.
</li>
<li>
	type <code>bar.S</code> doesn't implement the interface type <code>foo.I</code>.
</li>
</ul>

<pre class="line-numbers"><code class="language-go">package main

import "包2/foo"
import "包2/bar"

func main() {
	var x foo.S
	var y bar.S
	var _ foo.I = x
	var _ bar.I = y
	
	// The following lines fail to compile.
	x = foo.S(y)
	y = bar.S(x)
	var _ foo.I = y
	var _ bar.I = x
}
</code></pre>

</div>

<p class="anchor" id="errors-new-different-returns"></p>
<h3>Two <code>error</code> values returned by two <code>errors.New</code> calls with the same argument are not equal</h3>

<div>
The reason is the <code>errors.New</code> function will copy the input string argument
and use a pointer to the copied string as the dynamic value of the returned <code>error</code> value.
Two different calls will produce two different pointers.

<pre class="line-numbers"><code class="language-go">package main

import "fmt"
import "errors"

func main() {
	notfound := "not found"
	a, b := errors.New(notfound), errors.New(notfound)
	fmt.Println(a == b) // false
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="boolean-flag"></p>
<h3>The <code>flag</code> standard package treats boolean command flags differently than integer and string flags</h3>

<div>
There are three forms to pass command arguments.
<ol>
<li>
	<code>-flag</code>, for boolean flags only.
</li>
<li>
	<code>-flag=x</code>, for any flag.
</li>
<li>
	<code>-flag x</code>, for non-boolean flags only.
</li>
</ol>

<p>
And please note that, all items following a boolean flag with
the first form are viewed as arguments.
</p>

<pre class="line-numbers"><code class="language-go">package main

import "fmt"
import "flag"

var b = flag.Bool("b", true, "a boolean flag")
var i = flag.Int("i", 123, "an integer flag")
var s = flag.String("s", "hi", "a string flag")

func main() {
	flag.Parse()
	fmt.Print("b=", *b, ", i=", *i, ", s=", *s, "\n")
	fmt.Println("arguments:", flag.Args())
}
</code></pre>

<p>
</p>

If we run the following program with the below shown flags and arguments

<pre class="output"><code>./exampleProgram -b false -i 789 -s bye arg0 arg1
</code></pre>

the output will be

<pre class="output"><code>b=true, i=123, s=hi
arguments: [false -i 789 -s bye arg0 arg1]
</code></pre>

<p>
This output is obviously not what we expect.
</p>

We should pass the flags and arguments like

<pre class="output"><code>./exampleProgram -b=false -i 789 -s bye arg0 arg1
</code></pre>

or

<pre class="output"><code>./exampleProgram -i 789 -s bye -b arg0 arg1
</code></pre>

to get the output we expect:

<pre class="output"><code>b=true, i=789, s=bye
arguments: [arg0 arg1]
</code></pre>

</div>

<p class="anchor" id="capacity-of-slice-from-string"></p>
<h3>The capacity of the result slice of a conversion from a string to byte/rune slice may be larger than the length of the result slice</h3>

<div>
<p>
We should not assume the length and the capacity of the result slice are alway equal.
</p>

In the following example, if the last <code>fmt.Println</code> line is removed,
the outputs of the two lines before it print the same value <code>32</code>,
otherwise, one print <code>32</code> and one print <code>8</code>.
(For the standard Go compiler 1.10.)

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	s := "a"
	x := []byte(s)              // len(s) == 1
	fmt.Println(cap([]byte(s))) // 32
	fmt.Println(cap(x))         // 8
	fmt.Println(x)
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="printf-positional-arguments"></p>
<h3><code>[Sp|Fp|P]rintf</code> functions support positional arguments</h3>

<div>
<p>
The following program will print <code>3, 2, 1</code>.
</p>

An example:

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	fmt.Printf("%[3]v, %[2]v, %[1]v", 1, 2, 3) // 3, 2, 1
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="os-exit-runtime-goexit"></p>
<h3>Exit a program with a <code>os.Exit</code> function call and exit a goroutine with a <code>runtime.Goexit</code> function call</h3>

<div>
<p>
We can exit a program from any function by calling the <code>os.Exit</code> function.
An <code>os.Exit</code> function call takes an <code>int</code> code as
argument and returns the code to operating system.
</p>

An example:

<pre class="line-numbers"><code class="language-go">// exit-example.go
package main

import "os"
import "time"

func main() {
	go func() {
		time.Sleep(time.Second)
		os.Exit(1)
	}()
	select{}
}
</code></pre>

Run it:

<pre class="output"><code>$ go run a.go 
exit status 1
$ echo $?
1
</code></pre>

<p>
</p>

<p>
We can exit a goroutine by calling the <code>runtime.Goexit</code> function.
The <code>runtime.Goexit</code> function has no parameters.
</p>

An example:

<pre class="line-numbers"><code class="language-go">package main

import "fmt"
import "runtime"

func main() {
	c := make(chan int)
	go func() {
		defer func() {c <- 1}()
		defer fmt.Println("Go")
		func() {
			defer fmt.Println("C")
			runtime.Goexit()
		}()
		fmt.Println("Java")
	}()
	<-c
}
</code></pre>

<p>
</p>

</div>

<!---

strings.TrimRight/Left



The rule to deduce the type of untyped value a in a << b depends on whether or not b is a constant.

an untype rune or int constant can be bound with a value which is larger than the max <code>rune</code> or <code>int</code> value in memory.

-128/-1 = -128


greedy goroutine https://github.com/golang/go/issues/10958
* It look some goroutines never get yielded, this make some other goroutines never get chances to run, why?
http://stackoverflow.com/questions/13107958/what-exactly-does-runtime-gosched-do

internal package

"go doc xyz" may show the docs of the first package named with "xyz"
https://github.com/golang/go/issues/24462




https://github.com/golang/go/issues/13890

https://github.com/golang/go/issues/24693

https://github.com/golang/go/issues/24721

Try not to use multi-value assignments.
Reason 1: maybe bug. Reason 3: unspecified behaviours. 2: maybe inefficient.
https://github.com/golang/go/issues/23188#issuecomment-361482955
https://github.com/golang/go/issues/23017
https://github.com/golang/go/issues/22881
https://github.com/golang/go/issues/24448

https://github.com/golang/go/issues/24746

-->








