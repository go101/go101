<h1>Blocks And Scopes</h1>

<p>
This article will explain the code blocks and declaration scopes in Go.
</p>

<p><i>
(Please note, the definitions of code blocks and declaration scopes in this article
are a little different from the ones in <a href="https://golang.org/ref/spec">Go specification</a>.)
</i></p>

<!--
https://github.com/golang/go/issues/7429#issuecomment-282480782
-->

<p class="anchor" id="block"></p>
<h3>Code Blocks</h3>

<div>

In a Go project, there are four kinds of code blocks:
<ul>
<li>the <b>universe block</b> contains all project source code.</li>
<li>each package has a <b>package block</b> containing all source code,
	excluding the package import declarations in that package.</li>
<li>each file has a <b>file block</b> containing all the source code,
	including the package import declarations, in that file.</li>
<li>generally, a pair of braces <code>{}</code> opens and encloses a <b>local block</b>.
	The local blocks enclosed in <code>{}</code> are called explicit local blocks.
	The <code>{}</code> in composite literals and type definitions don't form
	local blocks.
</li>
</ul>

There are some exceptions and details for local blocks:
<ul>
<li>
	the input parameters and output results of a function are viewed as being
	declared in the local block enclosed by the pair of braces
	<code>{}</code> of the function definition, even if they stay out of
	the pair of braces.
</li>
<li>
	each <code>if</code>, <code>switch</code> and <code>for</code> keyword
	will open two nested local blocks. One is implicit, the other is explicit.
	The explicit one is nested in the implicit one.
	The variables declared with short declaration forms in the statements closely
	following the <code>if</code>, <code>switch</code> and <code>for</code> keywords
	are declared in the implicit block.
</li>
<li>
	an <code>else</code> keyword will open one explicit block, which is nested
	in the implicit block opened by its <code>if</code> counterpart keyword.
</li>
<li>
	each <code>case</code> and <code>default</code> keyword opens one implicit block,
	which is nested in the explicit block opened by its corresponding
	<code>switch</code> or <code>select</code> keyword.
</li>
</ul>

<p>
The local blocks which aren't nested in any other local blocks are called top level local blocks.
Top level local blocks are all function bodies.
</p>
</div>


<div>
Block hierarchies:
<ul>
<li>package blocks are nested in the universe block.</li>
<li>file blocks are also directly nested in the universe block, instead of package blocks.
	(This explanation is different from Go specification and the <code>go/*</code> standard packages.)
</li>
<li>each top level local block is nested in both a package block and a file block.
	(This explanation is also different from Go specification and the <code>go/*</code> standard packages.)
</li>
<li>a non-top local block must be nested in another local block.</li>
</ul>

<p><i>
(The differences to Go specification are to make the explanation of identifier shadowing
simpler below.)
</i></p>

Here is a picture shows the block hierarchies in a program:
<div class="text-center">
	<img src="./res/blocks.png">
</div>

<p>
</p>
</div>

<p>
Code blocks are mainly used to explain scopes of declared source code element identifiers.
</p>

<p class="anchor" id="declaration"></p>
<h3>Source Code Element Declaration Places</h3>

<div>
There are six kinds of source code elements which can be declared:
<ul>
<li>package imports.</li>
<li>types.</li>
<li>constants.</li>
<li>variables.</li>
<li>functions.</li>
<li>labels.</li>
</ul>
<p>
Labels are used in the <code>break</code>, <code>continue</code>, and <code>goto</code> statements.
</p>
</div>

<div>
The following table shows which code blocks all sorts of source code elements can be directly declared in:
<table class="table table-bordered text-center" style="width: auto !important;">
<thead>
	<tr>
	<th class="text-center"></th>
	<th class="text-center">the universe block</th>
	<th class="text-center">package blocks</th>
	<th class="text-center">file blocks</th>
	<th class="text-center">local blocks</th>
	</tr>
</thead>
<tbody>
	<tr class="active">
	<th scope="row" class="text-center">predeclared (built-in elements) <sup>(1)</sup></th>
	<td>Yes</td>
	<td></td>
	<td></td>
	<td></td>
	</tr>
	<tr>
	<th scope="row" class="text-center">package imports</th>
	<td></td>
	<td></td>
	<td>Yes</td>
	<td></td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center">types (non-builtin)</th>
	<td></td>
	<td>Yes</td>
	<td>Yes</td>
	<td>Yes</td>
	</tr>
	<tr>
	<th scope="row" class="text-center">constants (non-builtin)</th>
	<td></td>
	<td>Yes</td>
	<td>Yes</td>
	<td>Yes</td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center">variables (non-builtin) <sup>(2)</sup></th>
	<td></td>
	<td>Yes</td>
	<td>Yes</td>
	<td>Yes</td>
	</tr>
	<tr>
	<th scope="row" class="text-center">functions (non-builtin) <sup>(3)</sup></th>
	<td></td>
	<td>Yes</td>
	<td>Yes</td>
	<td></td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center">labels</th>
	<td></td>
	<td></td>
	<td></td>
	<td>Yes</td>
	</tr>
</tbody>
</table>
</div>

<p>
<sup>(1)</sup> predeclared elements are documented in <code>builtin</code> package.
<br/>
<sup>(2)</sup> excluding struct field variables.
<br/>
<sup>(3)</sup> excluding type methods.
</p>

<div>
Please note,
<ul>
<li>
package imports will never be declared in package and local blocks.
</li>
<li>
functions can't be declared in local blocks
(anonymous functions can be enclosed in local blocks but there is no way to declare them).
</li>
<li>
labels can only be declared in local blocks. 
And the intermost function block containing a label declaration
and the references of the label must be the same.
</li>
<li>
some special protions in all kinds of implicit local blocks have special requirements:
	<ul>
	<li>
	if the statement following a <code>if</code>, <code>switch</code> or <code>for</code> keyword
	is a declaration, it must be the short form of a variable declaration.
	No declarations can be contained directly in other protions of	the implicit blocks opened by these keywords.
	</li>
	<li>
	if the statement following a <code>case</code> keyword in a <code>select</code> block
	is a declaration, it must be the short form of a variable declaration.
	</li>
	</ul>
</li>
<li>
if the innermost function blocks of two label declarations are the same one,
then the names of two labels can't be duplicated.
</li>
<li>
except labels, if the innermost blocks of two declared identifiers are the same one,
then the two identifiers can't be identical.
</li>
</ul>
<p><i>
(BTW, the <code>go/*</code> standard packages think file code blocks can only contain package import declarations.)
</i></p>
</div>

<p>
The source code elements declared in package blocks but outside any local blocks are called package-level source code elements.
Package-level source code elements can be constants, types, variables, or functions, but not labels and package imports.
</p>

<p>
Each package-level source code element identifier is directly contained
both in a package block and a file block.
</p>

<p class="anchor" id="scope"></p>
<h3>Scopes Of Declared Source Code Elements</h3>

<div>
The scope of an declared identifier is the identifiable range of the identifier.
Here are <a href="https://golang.org/ref/spec#Declarations_and_scope">the scope definitions</a>
for all kinds of source code element identifiers:
<ul>
<li>
	the scope of a predeclared/built-in identifier is the universe block.
</li>
<li>
	the scope of a package import identifier is the file block containing the identifier.
</li>
<li>
	the scope of an identifier denoting a constant, type, variable, or function
	(but not method) declared at package level is the package block.
	In particular, if the identifier denotes a constant or a variable,
	its scope doesn't include the line the identifier is declared at.
</li>
<li>
	the scope of an identifier denoting a method receiver, function parameter, 
	or result variable is the corresponding function body (a local block).
</li>
<li>
	the scope of a constant or variable identifier declared inside a local block
	begins at the end of its declaration statement and ends at the end of the innermost containing block.
</li>
<li>
	the scope of a type identifier defined inside a local block begins at the start
	of its definition and ends at the end of the innermost containing block.
</li>
<li>
	the scope of a type alias identifier declared inside a local block begins at the end
	of its declaraion and ends at the end of the innermost containing block.
</li>
<li>
	the scope of a label is the body of the innermost function local block containing the label declaration
	but excludes all the bodies of anonymous functions nested in the containing function.
	In other words, labels can't be referenced crossing function bodies.
</li>
</ul>
</div>

<p>
The elements declared with the blank identifier are not really declared and have no scopes.
</p>

<p><i>
(The predeclared <code>iota</code> is only visible in constant declarations.)
</i></p>

<div>
Yoy may have noticed the minor difference of scope definitions between local type identifiers
and local variable/constant/alias identifiers. The difference means a defined type may be able to
reference itself in its definition body. Here is an example to show it more clearly:
<pre class="line-numbers"><code class="language-go">package main

func main() {
	// var v int = v   // error: undefined: v
	// const C int = C // error: undefined: C
	/*
	type T = struct {
		*T // invalid recursive type alias T
	}
	*/
	
	// following type declrations are all legal.
	type T struct {
		*T
	}
	type A [5]*A
	type S []S
	type M map[int]M
	type F func(F) F
	type Ch chan Ch
	type P *P
	
	// ...
	
	var s = make(S, 3)
	s[0] = s
	s = s[0][0][0][0][0][0][0][0]
	
	var m = M{}
	m[1] = m
	m = m[1][1][1][1][1][1][1][1]
	
	var p P
	p = &p
	p = ***********************p
}
</code></pre>

And the scope difference between package-level and local declarations:
<pre class="line-numbers"><code class="language-go">package main

// Here the two identifiers at each line are the same one.
/*
const iota = iota // error: constant definition loop
var true = true   // error: typechecking loop
*/

var a = b   // can reference variables declared later
var b = 123

func main() {
	// The right identifiers in the next two lines are
	// predecalred ones.
	const iota = iota // ok
	var true = true   // ok
	_ = true
	
	// The following lines fail to compile.
	/*
	var c = d // can't reference variables declared later.
	var d = 123
	_ = c
	*/
}
</code></pre>
</div>

<p class="anchor" id="shadow"></p>
<h3>Identifier Shadowing</h3>

<div>
<p>
Except labels, an identifier declared in an outer code blocks can be
shadowed by the same identifier declared
in code blocks nested in the outer code block.
</p>

<p>
Labels can’t be shadowed.
</p>

<p>
If an identifier is shadowed, its scope will exclude the scopes of its shadowing identifiers.
</p>

Below is an interesting example.
The code contains 4 declared variables named <code>x</code>.
A <code>x</code> declared in an innerer block will shadow
the <code>x</code>s declared in outerer blocks.
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

var x = 9999
var p0 = &x
var p1, p2, p3 *int

func main() {
	var x = 888
	p1 = &x
	for x := 0; x < 5; x++ {
		p2 = &x
		x := x + 100
		p3 = &x
	}
	
	fmt.Println(*p0, *p1, *p2, *p3) // 9999 888 5 104
}
</code></pre>

Here is another example which is some weird.
Its compiles and runs okay.
<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
)

const len = 3 // shadows the built-in function identifier "len".

var true = 0 // shadows the built-in const identifier "true".

type nil struct {} // shadows the built-in variable identifier "nil".

func int(){} // shadows the built-in type identifier "int".

func main() {
	fmt.Println("a weird program")
	var print = fmt.Println
	
	var fmt = [len]nil{{}, {}, {}} // shadows the package import "fmt".
	// var n = len(fmt) // sorry, "len" is a constant.
	var n = cap(fmt)    // use built-in cap function instead, :(

	// the "for" keyword will open one implicit local code block and
	// one explicit local code block.
	for true := 0; true < n; true++ {
		var false = fmt[true] // shadows the built-in const
		                      // the built-in identifier "false".
		var true = true+1 // the new declared "true" variable
		                  // shadows the iteration variable "true".
		// fmt.Println(true, false) // sorry, "fmt" is an array.
		print(true, false)
	}
}

/* output:
a weird program
1 {}
2 {}
3 {}
*/
</code></pre>
<p>
Yes, this example is extreme.
It contains many bad practices.
Identifier shadowing is useful, but please don't abuse it.
</p>
</div>



<!--
Blocks
* universal block: 顶级区
* file block: 文件区（只对package import有效）
* package block: 包级区（口头上不准确的说法为全局区）
* local block: 局部区

本书将会可以避免全局变量这个词
-->



