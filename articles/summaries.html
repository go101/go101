<h1>Some Simple Summaries</h1>

<div>
Index
<ul>
<li><a href="#type-with-underlyings">Types whose values may have indirect underlying parts</a>.</li>
<li><a href="#have-length-types">Types which values can be used as arguments of built-in <code>len</code> function
	(and <code>cap</code>, <code>close</code>, <code>delete</code>, <code>make</code> functions)</a>.</li>
<li><a href="#container-types">Comparison of built-in container types</a>.</li>
<li><a href="#composite-literals-types">Types which values can be represented with composite literals (<code>T{...}</code>)</a>.</li>
<li><a href="#type-sizes">Value sizes of all kinds of types</a>.</li>
<li><a href="#nil-zero-value-types">Types which zero values can be represented with <code>nil</code></a>.</li>
<li><a href="#types-can-have-methods">Types we can implement methods for</a>.</li>
<li><a href="#types-can-be-embedded">Types which can be embedded in struct types</a>.</li>
<li><a href="#compile-time-evaluation">Functions whose calls will/may be evaluated at compile time</a>.</li>
<li><a href="#not-addressable">Values that can't be taken addresses</a>.</li>
<li><a href="#not-comparable">Types which don't support comparisons</a>.</li>
<li><a href="#declared-but-unused">Which code elements are allowed to be declared but not used</a>.</li>
<li><a href="#groupable-elements">Named source code elements which declarations can be grouped with <code>()</code></a>.</li>
<li><a href="#declaration-places">Named source code elements which can be declared both inside functions and outside any functions</a>.</li>
<li><a href="#additional-return">Expressions which evaluation results may contain optional additional values</a>.</li>
<li><a href="#block-forever">Ways to block the current goroutine ‎forever by using the channel mechanism</a>.</li>
<li><a href="#concatenate-strings">Ways to concatenate strings</a>.</li>
</ul>

<p>
</p>

Besides the current article, there are also some other summary articles
for some special topics, including
<ul>
<li>
	<a href="nil.html"><code>nil</code> In Go</a>.
</li>
<li>
	<a href="value-conversions-assignments-and-comparisons.html">value conversion,
	assignment and comparison rules in Go</a>.
</li>
<li>
	<a href="exceptions.html">syntax/semantics exceptions in Go</a>.
</li>
</ul>
</div>

<p class="anchor" id="type-with-underlyings"></p>
<h3>
	Types whose values may have indirect underlying parts
</h3>

<div>
Types whose values may have indirect underlying parts:
<ul>
<li>string types</li>
<li>function types</li>
<li>slice types</li>
<li>map types</li>
<li>channel types</li>
<li>interface types</li>
</ul>

<p>
The answer is based on the implementations of the standard Go compiler/runtime.
In fact, whether or not function values may have indirect underlying parts is hardly to prove,
and string values and interface values should be viewed as values without indirect underlying parts in logic.
Please read <a href="value-part.html">value parts</a> for details.
</p>
</div>

<p class="anchor" id="have-length-types"></p>
<h3>
	Types which values can be used as arguments of built-in <code>len</code> function
	(and <code>cap</code>, <code>close</code>, <code>delete</code>, <code>make</code> functions)
</h3>

<table class="table table-bordered text-center" style="width: auto !important;">
<thead>
	<tr>
	<th class="text-center"></th>
	<th class="text-center">len</th>
	<th class="text-center">cap</th>
	<th class="text-center">close</th>
	<th class="text-center">delete</th>
	<th class="text-center">make</th>
	</tr>
</thead>
<tbody>
	<tr class="active">
	<th scope="row" class="text-center">string</th>
	<td>Yes</td>
	<td></td>
	<td></td>
	<td></td>
	<td></td>
	</tr>
	<tr>
	<th scope="row" class="text-center">array<br/>(and array pointer)</th>
	<td>Yes</td>
	<td>Yes</td>
	<td></td>
	<td></td>
	<td></td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center">slice</th>
	<td>Yes</td>
	<td>Yes</td>
	<td></td>
	<td></td>
	<td>Yes</td>
	</tr>
	<tr>
	<th scope="row" class="text-center">map</th>
	<td>Yes</td>
	<td></td>
	<td></td>
	<td>Yes</td>
	<td>Yes</td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center">channel</th>
	<td>Yes</td>
	<td>Yes</td>
	<td>Yes</td>
	<td></td>
	<td>Yes</td>
	</tr>
</tbody>
</table>

<p>
Values of above types can also be ranged over in for-range loops.
</p>

<p>
Types which values can be used as arguments of built-in function <code>len</code>
can be called container types in broad sense.
</p>

<p class="anchor" id="container-types"></p>
<h3>
	Comparison of built-in container types
</h3>

<table class="table table-bordered text-center" style="width: auto !important;">
<thead>
	<tr>
	<th class="text-center">Type</th>
	<th class="text-center">Can New Elements Be Added Into Values?</th>
	<th class="text-center">Are Elements Of Values Replaceable?</th>
	<th class="text-center">Are Elements Of Values Addressable?</th>
	<th class="text-center">Will Element Accesses Modify Value Lengths?</th>
	<th class="text-center">May Values Have Underlying Parts</th>
	</tr>
</thead>
<tbody>
	<tr class="active">
	<th scope="row" class="text-center">string</th>
	<td>No</td>
	<td>No</td>
	<td>No</td>
	<td>No</td>
	<td>Yes<sup>(1)</sup></td>
	</tr>
	<tr>
	<th scope="row" class="text-center">array</th>
	<td>No</td>
	<td>Yes<sup>(2)</sup></td>
	<td>Yes<sup>(2)</sup></td>
	<td>No</td>
	<td>No</td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center">slice</th>
	<td>No<sup>(3)</sup></td>
	<td>Yes</td>
	<td>Yes</td>
	<td>No</td>
	<td>Yes</td>
	</tr>
	<tr>
	<th scope="row" class="text-center">map</th>
	<td>Yes</td>
	<td>Yes</td>
	<td>No</td>
	<td>No</td>
	<td>Yes</td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center">channel</th>
	<td>Yes<sup>(4)</sup></td>
	<td>No</td>
	<td>No</td>
	<td>Yes</td>
	<td>Yes</td>
	</tr>
</tbody>
</table>

<p>
<sup>(1)</sup> For the standard Go compiler/runtime.
<br/>
<sup>(2)</sup> For addressable array values only.
<br/>
<sup>(3)</sup> Generally, a slice value are modified by assigned another slice value to it by overwriting it.
Here, such cases are not viewed as "add new elements".
In fact, slice lengths can also be modified separately by calling the <code>reflect.SetLen</code> function.
Increase the length of a slice by this way is kind of adding new elements into the slice.
But the <code>reflect.SetLen</code> function is slow, so it is rarely used.
<br/>
<sup>(4)</sup> For buffered channels which are still not full.
</p>

<p class="anchor" id="composite-literals-types"></p>
<h3>
	Types which values can be represented with composite literals (<code>T{...}</code>)
</h3>

<p>
Values of the following four kinds of types can be represented with composite literals:
</p>

<table class="table table-bordered text-center" style="width: auto !important;">
<thead>
	<tr>
	<th class="text-center">Type (<code>T</code>)</th>
	<th class="text-center">Is <code>T{}</code> A Zero Value Of <code>T</code>?</th>
	</tr>
</thead>
<tbody>
	<tr class="active">
	<th scope="row" class="text-center">struct</th>
	<td>Yes</td>
	</tr>
	<tr>
	<th scope="row" class="text-center">array</th>
	<td>Yes</td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center" style="vertical-align: middle">slice</th>
	<td>No<br/>(zero value is <code>nil</code>)</td>
	</tr>
	<tr>
	<th scope="row" class="text-center" style="vertical-align: middle">map</th>
	<td>No<br/>(zero value is <code>nil</code>)</td>
	</tr>
</tbody>
</table>

<p class="anchor" id="type-sizes"></p>
<h3>
	Value sizes of all kinds of types
</h3>

<p>
Please read <a href="value-copy-cost.html">value copy cost</a> for details.
</p>

<p class="anchor" id="nil-zero-value-types"></p>
<h3>
	Types which zero values can be represented with <code>nil</code>
</h3>

<p>
The zero values of the following types can be represented with <code>nil</code>.
</p>

<table class="table table-bordered text-center" style="width: auto !important;">
<thead>
	<tr>
	<th class="text-center">Type (<code>T</code>)</th>
	<th class="text-center">Size Of <code>T(nil)</code></th>
	</tr>
</thead>
<tbody>
	<tr class="active">
	<th scope="row" class="text-center">pointer</th>
	<td>1 word</td>
	</tr>
	<tr>
	<th scope="row" class="text-center">slice</th>
	<td>3 words</td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center">map</th>
	<td>1 word</td>
	</tr>
	<tr>
	<th scope="row" class="text-center">channel</th>
	<td>1 word</td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center">function</th>
	<td>1 word</td>
	</tr>
	<tr>
	<th scope="row" class="text-center">interface</th>
	<td>2 words</td>
	</tr>
</tbody>
</table>

<p>
The above listed sizes are for the standard Go compiler.
One word means 4 bytes on 32-bit architectures and 8 bytes on 64-bit architectures.
and <a href="value-part.html">the indirect underlying parts</a>
of a value don't contribute to the size of the value.
</p>

<p>
The size of a zero value of a type is the same as any other values of the same type.
</p>

<p class="anchor" id="types-can-have-methods"></p>
<h3>
	Types we can implement methods for
</h3>

<p>
Please read <a href="method.html">methods in Go</a> for details.
</p>

<p class="anchor" id="types-can-be-embedded"></p>
<h3>
	Types which can be embedded in struct types
</h3>

<p>
Please read <a href="type-embedding.html#embeddable-types">which types
can be embedded</a> for details.
</p>

<p class="anchor" id="compile-time-evaluation"></p>
<h3>
	Functions whose calls will/may be evaluated at compile time
</h3>

<p>
If a function call is evaluated at compile time,
its return results must be constants.
</p>

<table class="table table-bordered text-center" style="width: auto !important;">
<thead>
	<tr>
	<th class="text-center">Function</th>
	<th class="text-center">Return Type</th>
	<th class="text-center">Are Calls Always Evaluated At Compile Time?</th>
	</tr>
</thead>
<tbody>
	<tr class="active">
	<th scope="row" class="text-center">unsafe.Sizeof</th>
	<td rowspan="3" style="vertical-align: middle"><code>uintptr</code></td>
	<td rowspan="3" style="vertical-align: middle">Yes, always.</td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center" style="vertical-align: middle">unsafe.Alignof</th>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center" style="vertical-align: middle">unsafe.Offsetof</th>
	</tr>
	<tr>
	<th scope="row" class="text-center" style="vertical-align: middle">len</th>
	<td rowspan="2" style="vertical-align: middle"><code>int</code></td>
	<td rowspan="2">
		Not always.
		<br/><br/>
		<div class="text-left">
		From <a href="https://golang.org/ref/spec#Length_and_capacity">Go specification</a>:
		<ul>
		<li>
		the expression <code>len(s)</code> is constant if <code>s</code> is a string constant.
		</li>
		<li>
		the expressions <code>len(s)</code> and <code>cap(s)</code> are constants
		if the type of <code>s</code> is an array or pointer to an array
		and the expression <code>s</code> does not contain channel receives or (non-constant) function calls.
		</li>
		</ul>
		</div>
	</td>
	</tr>
	<tr>
	<th scope="row" class="text-center" style="vertical-align: middle">cap</th>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center" style="vertical-align: middle">real</th>
	<td rowspan="2" style="vertical-align: middle"><code>float64</code><br/>(default type)</td>
	<td rowspan="2">
		Not always.
		<br/><br/>
		<div class="text-left">
		From <a href="https://golang.org/ref/spec#Constants">Go spec</a>:
		the expressions <code>real(s)</code> and <code>imag(s)</code> are constants
		if <code>s</code> is a complex constant.
		</div>
	</td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center" style="vertical-align: middle">imag</th>
	</tr>
	<tr>
	<th scope="row" class="text-center" style="vertical-align: middle">complex</th>
	<td style="vertical-align: middle"><code>complex128</code><br/>(default type)</td>
	<td>
		Not always.
		<br/><br/>
		<div class="text-left">
		From <a href="https://golang.org/ref/spec#Constants">Go spec</a>:
		the expression <code>complex(sr, si)</code> is constant
		if both <code>sr</code> and <code>si</code> are numeric constants.
		</div>
	</td>
	</tr>
</tbody>
</table>

<p class="anchor" id="not-addressable"></p>
<h3>
	Addressable and unaddressable values
</h3>

<p>
Please read <a href="unofficial-faq.html#unaddressable-values">this FAQ item</a>
to get which values are addressable or unaddressable.
</p>

<p class="anchor" id="not-comparable"></p>
<h3>
	Types which don't support comparisons
</h3>

<p>
Please read <a href="unofficial-faq.html#uncomparable-types">this FAQ item</a>
to get which values are addressable or unaddressable.
</p>

<p class="anchor" id="declared-but-unused"></p>
<h3>
	Which code elements are allowed to be declared but not used
</h3>

<table class="table table-bordered text-center" style="width: auto !important;">
<thead>
	<tr>
	<th class="text-center"></th>
	<th class="text-center">Allowed To Be Declared But Not Used?</th>
	</tr>
</thead>
<tbody>
	<tr class="active">
	<th scope="row" class="text-center">import</th>
	<td>No</td>
	</tr>
	<tr>
	<th scope="row" class="text-center">type</th>
	<td>Yes</td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center">variable</th>
	<td>
		Yes for package-level variables.
		<br/>
		No for local variables (for the standard compiler).
	</td>
	</tr>
	<tr>
	<th scope="row" class="text-center">constant</th>
	<td>Yes</td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center">function</th>
	<td>Yes</td>
	</tr>
	<tr>
	<th scope="row" class="text-center">label</th>
	<td>No</td>
	</tr>
</tbody>
</table>

<p class="anchor" id="groupable-elements"></p>
<h3>
	Named source code elements which declarations can be grouped with <code>()</code>
</h3>

<div>
Following named source code element declarations can be grouped with <code>()</code>:
<ul>
<li>import</li>
<li>type</li>
<li>variable</li>
<li>constant</li>
</ul>
</div>
<p>
Functions and labels can't be grouped.
</p>

<p class="anchor" id="declaration-places"></p>
<h3>
	Named source code elements which can be declared both inside functions and outside any functions
</h3>

<div>
Following named source code elements can be declared both inside functions and outside any functions:
<ul>
<li>type</li>
<li>variable</li>
<li>constant</li>
</ul>
</div>
<p>
Imports must be declared before declarations of other elements (and after the package clause).
</p>
<p>
Functions can only be declared outside any functions.
Anonymous functions can be defined inside other function bodies,
but such definitions are not function declarations.
</p>
<p>
Labels must be declared inside functions.
</p>

<p class="anchor" id="additional-return"></p>
<h3>
	Expressions which evaluation results may contain optional additional values
</h3>

<p>
The evaluation results of the following expressions may contain optional additional values:
</p>

<table class="table table-bordered text-center" style="width: auto !important;">
<thead>
	<tr>
	<th class="text-center"></th>
	<th class="text-center">Syntax</th>
	<th class="text-center">Meaning Of The Optional Value (<code>ok</code> in the syntax examples)</th>
	<th class="text-center">Will Omitting The Optional Return Affect Program Behavior?</th>
	</tr>
</thead>
<tbody>
	<tr class="active">
	<th scope="row" class="text-center" style="vertical-align: middle">map element access</th>
	<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
		<code>e, ok = aMap[key]</code>
	</td>
	<td>whether or not the accessed key is present in the map</td>
	<td>No</td>
	</tr>
	<tr>
	<th scope="row" class="text-center" style="vertical-align: middle">channel value receive</th>
	<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
		<code>e, ok = &lt;- aChannel</code>
	</td>
	<td>whether or not the received value was sent before the channel was closed</td>
	<td>No</td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center" style="vertical-align: middle">type assertion</th>
	<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
		<code>v, ok = anInterface.(T)</code>
	</td>
	<td>whether or not the dynamic type of the interface value matches the asserted type</td>
	<td>Yes<br/>(when the optional bool return is omitted,
		a panic is created if the asserted type is not an ok type.)</td>
	</tr>
</tbody>
</table>

<p class="anchor" id="block-forever"></p>
<h3>
	Ways to block the current goroutine ‎forever by using the channel mechanism
</h3>

<div>
Without importing any package, we can use the following ways to make the current goroutine ‎enter (and stay in) blocking state forever:
<ol>
<li>send a value to a channel which no ones will receive values from
	<div>
<pre class="disable-line-numbers111"><code class="language-go">make(chan struct{}) <- struct{}{}
// or
make(chan<- struct{}) <- struct{}{}
</code></pre>
	</div>
</li>
<li>receive a value from a never-closed channel which no values have been and will be sent to
	<div>
<pre class="disable-line-numbers111"><code class="language-go"><-make(chan struct{})
// or
<-make(<-chan struct{})
// or
for range make(<-chan struct{}) {}
</code></pre>
	</div>
</li>
<li>receive a value from (or send a value to) a nil channel
	<div>
<pre class="disable-line-numbers111"><code class="language-go">chan struct{}(nil) <- struct{}{}
// or
<-chan struct{}(nil)
// or
for range chan struct{}(nil) {}
</code></pre>
	</div>
</li>
<li>use a bare select block
	<div>
<pre class="disable-line-numbers111"><code class="language-go">select{}
</code></pre>
	</div>
</li>
</ol>
</div>

<p class="anchor" id="concatenate-strings"></p>
<h3>
	Ways to concatenate strings
</h3>

<p>
Please read <a href="string.html#string-concatenation">strings in Go</a> for details.
</p>


<!--

Fatal errors which can be recovered:
* https://play.golang.org/p/bYrfLTzXpc_o bad Mutex.Unlock call. unlock of unlocked lock
* create goroutine with nil function
* memory allcaotion fails, out of memory, alloc too large
* stack overflow
* map data race operation
  * concurrent map iteration and map write
  * concurrent map read and map write
  * concurrent map writes
* cgo callback before cgo call
* thread exhaustion
	package main
	import "runtime/debug"
	import "runtime"
	func main() {
		debug.SetMaxThreads(10)
		c := make(chan int)
		for i := 0; i < 100; i++ {
			go func() {
				runtime.LockOSThread()
				c <- 0
				select {}
			}()
			<-c
		}
	}
* load bad Go plugins
* all goroutines are blocked.
* string concatenation too long

The optimizations made by gc
* len([]rune(str)) // since Go 1.11
* string ...
  []byte <-> stirng
  len([]rune(string))
  string + string
* since Go 1.11, https://github.com/golang/go/issues/21266#issuecomment-384706868
  possible future append(s, make([]T)) optimiation
  https://docs.google.com/presentation/d/1tpeJZFObkeick4CF-mx0L3CeCgvT15B96aJeRpxEPcE/preview#slide=id.g3bc6fcf60c_0_62
* memclr
* interface copy
* interface dynamic pointer value
* 4 fields struct is much faster than more field struct
  https://docs.google.com/presentation/d/1tpeJZFObkeick4CF-mx0L3CeCgvT15B96aJeRpxEPcE/preview#slide=id.g3bc6fcf60c_0_157
* BCE
  https://docs.google.com/presentation/d/1tpeJZFObkeick4CF-mx0L3CeCgvT15B96aJeRpxEPcE/preview#slide=id.g3bc6fcf60c_0_169


short and standard variable declaration comparison

differences between built-in functions and custom functions.
  * generic
  * built-in function returns can't be omitted
  * builtin-in functions can't be used as values, they have no types.
  * built-in doon't need to be imported before using them, even their identifiers starts with lower..
  *

built-in function list

	"append":  predeclaredFunction,
	"cap":     predeclaredFunction,
	"close":   predeclaredFunction,
	"complex": predeclaredFunction,
	"copy":    predeclaredFunction,
	"delete":  predeclaredFunction,
	"imag":    predeclaredFunction,
	"len":     predeclaredFunction,
	"make":    predeclaredFunction,
	"new":     predeclaredFunction,
	"panic":   predeclaredFunction,
	"print":   predeclaredFunction,
	"println": predeclaredFunction,
	"real":    predeclaredFunction,
	"recover": predeclaredFunction,


#returns-discardable
return results of calls to which built-in functions can be discarded.

values of which kinds of types can be for-ranged.

ways to return a function: naturally return, return keyword, panic, runtime.Goexit()

the form <code>v[k]</code> can be used to access elements of values of which kinds of types?


unspecified behaviors:
* when explicitly convert a non-constant value to a floating or complex type,
  and overflow happens, then the result depends on compilers.
* expression evaluation order
* the capacity of result of converting string to byte and rune slices
* 

-->

<!--
todo:
	kinds of control flow blocks
	control flow statements
		return, break, fallthrough, continue, goto
	which control flow statements can be followed a label.
	which control flow statements can appean in which control flow blocks

-->
