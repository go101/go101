<h1>Simple Summaries</h1>

<div>
Index
<ul>
<li><a href="#type-with-underlyings">Types whose values may have indirect underlying parts</a>.</li>
<li><a href="#have-length-types">Types which values can be used as arguments of built-in function <code>len</code>
	(and functions <code>cap</code>, <code>close</code>, <code>delete</code>, <code>make</code>)</a>.</li>
<li><a href="#container-types">Comparison of built-in container types</a>.</li>
<li><a href="#composite-literals-types">Types which values can be represented with composite literals (<code>T{...}</code>)</a>.</li>
<li><a href="#type-sizes">Value sizes of all kinds of types</a>.</li>
<li><a href="#nil-zero-value-types">Types which zero values can be represented with <code>nil</code></a>.</li>
<li><a href="#types-can-have-methods">Types we can implement methods for</a>.</li>
<li><a href="#types-can-be-embedded">Types which can be anonymously embedded in other types</a>.</li>
<li><a href="#compile-time-evaluation">Functions whose calls will/may be evaluated at compile time</a>.</li>
<li><a href="#not-addressable">Values that can't be taken addresses</a>.</li>
<li><a href="#not-comparable">Types which don't support comparisons</a>.</li>
<li><a href="#declared-but-unused">Which code elements are allowed to be declared but not used</a>.</li>
<li><a href="#groupable-elements">Named source code elements which declarations can be grouped with <code>()</code></a>.</li>
<li><a href="#declaration-places">Named source code elements which can be declared both inside functions and outside any functions</a>.</li>
<li><a href="#additional-return">Expressions which may return an optional additional return value</a>.</li>
<li><a href="#block-forever">Ways to block current goroutine ‎forever by using the channel mechanism</a>.</li>
<li><a href="#concatenate-strings">Ways to concatenate strings</a>.</li>
</ul>

<p>
</p>

Besides the current article, there also some other summary articles
for some special topics, including
<ul>
<li>
	<a href="nil.html"><code>nil</code> In Go</a>.
</li>
<li>
	<a href="value-conversions-assignments-and-comparisons.html">value conversion,
	assignment and comparison rules in Go</a>.
</li>
<li>
	<a href="exceptions.html">syntax/semantics exceptions in Go</a>.
</li>
</ul>
</div>

<p class="anchor" id="type-with-underlyings"></p>
<h3>
	Types whose values may have indirect underlying parts
</h3>

<div>
Types whose values may have indirect underlying parts:
<ul>
<li>string types</li>
<li>function types</li>
<li>slice types</li>
<li>map types</li>
<li>channel types</li>
<li>interface types</li>
</ul>
<p>
<a href="value-part.html">This article</a> lists the
internal definitions of above types by the standard Go compiler/runtime.
</p>
</div>

<p class="anchor" id="have-length-types"></p>
<h3>
	Types which values can be used as arguments of built-in function <code>len</code>
	(and functions <code>cap</code>, <code>close</code>, <code>delete</code>, <code>make</code>)
</h3>

<table class="table table-bordered text-center" style="width: auto !important;">
<thead>
	<tr>
	<th class="text-center"></th>
	<th class="text-center">len</th>
	<th class="text-center">cap</th>
	<th class="text-center">close</th>
	<th class="text-center">delete</th>
	<th class="text-center">make</th>
	</tr>
</thead>
<tbody>
	<tr class="active">
	<th scope="row" class="text-center">string</th>
	<td>Yes</td>
	<td></td>
	<td></td>
	<td></td>
	<td></td>
	</tr>
	<tr>
	<th scope="row" class="text-center">array<br/>(and array pointer)</th>
	<td>Yes</td>
	<td>Yes</td>
	<td></td>
	<td></td>
	<td></td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center">slice</th>
	<td>Yes</td>
	<td>Yes</td>
	<td></td>
	<td></td>
	<td>Yes</td>
	</tr>
	<tr>
	<th scope="row" class="text-center">map</th>
	<td>Yes</td>
	<td></td>
	<td></td>
	<td>Yes</td>
	<td>Yes</td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center">channel</th>
	<td>Yes</td>
	<td>Yes</td>
	<td>Yes</td>
	<td></td>
	<td>Yes</td>
	</tr>
</tbody>
</table>

<p>
Values of above types can also be ranged over in for-range loops.
</p>

<p>
Types which values can be used as arguments of built-in function <code>len</code>
can be called container types.
</p>

<p class="anchor" id="container-types"></p>
<h3>
	Comparison of built-in container types
</h3>

<table class="table table-bordered text-center" style="width: auto !important;">
<thead>
	<tr>
	<th class="text-center">Type</th>
	<th class="text-center">Can New Elements Be Added Into Values?</th>
	<th class="text-center">Are Elements Of Values Replaceable?</th>
	<th class="text-center">Are Elements Of Values Addressable?</th>
	<th class="text-center">Will Element Accessments Modify Value Lengths?</th>
	<th class="text-center">May Values Have Underlying Parts</th>
	</tr>
</thead>
<tbody>
	<tr class="active">
	<th scope="row" class="text-center">string</th>
	<td>No</td>
	<td>No</td>
	<td>No</td>
	<td>No</td>
	<td>Yes<sup>(1)</sup></td>
	</tr>
	<tr>
	<th scope="row" class="text-center">array</th>
	<td>No</td>
	<td>Yes<sup>(2)</sup></td>
	<td>Yes<sup>(2)</sup></td>
	<td>No</td>
	<td>No</td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center">slice</th>
	<td>No<sup>(3)</sup></td>
	<td>Yes</td>
	<td>Yes</td>
	<td>No</td>
	<td>Yes</td>
	</tr>
	<tr>
	<th scope="row" class="text-center">map</th>
	<td>Yes</td>
	<td>Yes</td>
	<td>No</td>
	<td>No</td>
	<td>Yes</td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center">channel</th>
	<td>Yes<sup>(4)</sup></td>
	<td>No</td>
	<td>No</td>
	<td>Yes</td>
	<td>Yes</td>
	</tr>
</tbody>
</table>

<p>
<sup>(1)</sup> for the standard Go compiler/runtime.
<br/>
<sup>(2)</sup> for addressable array values only.
<br/>
<sup>(3)</sup> slice lengths can be modified by using <code>reflect.SetLen</code> function.
Increase the length of a slice by this way is kind of adding new elements into the slice.
The length of a slice value can also be modified by assigning another slice value to it.
<br/>
<sup>(4)</sup> for buffered channels which are still not full.
</p>

<p class="anchor" id="composite-literals-types"></p>
<h3>
	Types which values can be represented with composite literals (<code>T{...}</code>)
</h3>

<p>
Values of following types can be represented with composite literals:
</p>

<table class="table table-bordered text-center" style="width: auto !important;">
<thead>
	<tr>
	<th class="text-center">Type (<code>T</code>)</th>
	<th class="text-center">Is <code>T{}</code> A Zero Value Of <code>T</code>?</th>
	</tr>
</thead>
<tbody>
	<tr class="active">
	<th scope="row" class="text-center">struct</th>
	<td>Yes</td>
	</tr>
	<tr>
	<th scope="row" class="text-center">array</th>
	<td>Yes</td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center" style="vertical-align: middle">slice</th>
	<td>No<br/>(zero value is <code>nil</code>)</td>
	</tr>
	<tr>
	<th scope="row" class="text-center" style="vertical-align: middle">map</th>
	<td>No<br/>(zero value is <code>nil</code>)</td>
	</tr>
</tbody>
</table>

<p class="anchor" id="type-sizes"></p>
<h3>
	Value sizes of all kinds of types
</h3>

<p>
Please read <a href="value-copy-cost.html">value copy cost</a> for details.
</p>

<p class="anchor" id="nil-zero-value-types"></p>
<h3>
	Types which zero values can be represented with <code>nil</code>
</h3>

<p>
The zero values of the following types can be represented with <code>nil</code>.
</p>

<table class="table table-bordered text-center" style="width: auto !important;">
<thead>
	<tr>
	<th class="text-center">Type (<code>T</code>)</th>
	<th class="text-center">Size Of <code>T(nil)</code></th>
	</tr>
</thead>
<tbody>
	<tr class="active">
	<th scope="row" class="text-center">pointer</th>
	<td>1 word</td>
	</tr>
	<tr>
	<th scope="row" class="text-center">slice</th>
	<td>3 words</td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center">map</th>
	<td>1 word</td>
	</tr>
	<tr>
	<th scope="row" class="text-center">channel</th>
	<td>1 word</td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center">function</th>
	<td>1 word</td>
	</tr>
	<tr>
	<th scope="row" class="text-center">interface</th>
	<td>2 words</td>
	</tr>
</tbody>
</table>

<p><i>
(One word means 4 bytes on 32bits OSes and 8 bytes on 64bits OSes.
and <a href="value-part.html">the indirect underlying parts</a>
of a value don't contribute to the size of the value.)
</i></p>

<p>
The size of a zero value of a type is the same as any other values of the same type.
</p>

<p class="anchor" id="types-can-have-methods"></p>
<h3>
	Types we can implement methods for
</h3>

<p>
Please read <a href="unofficial-faq.html#types-can-have-methods">this
question</a> for details.
</p>

<p class="anchor" id="types-can-be-embedded"></p>
<h3>
	Types which can be anonymously embedded in other types
</h3>

<p>
Please read <a href="type-embedding.html#embeddable-types">which types
can be embedded</a> for details.
</p>

<p class="anchor" id="compile-time-evaluation"></p>
<h3>
	Functions whose calls will/may be evaluated at compile time
</h3>

<p>
If a function call is evaluated at compile time,
its return results must be constants.
</p>

<table class="table table-bordered text-center" style="width: auto !important;">
<thead>
	<tr>
	<th class="text-center">Function</th>
	<th class="text-center">Return Type</th>
	<th class="text-center">Are Calls Always Evaluated At Compile Time?</th>
	</tr>
</thead>
<tbody>
	<tr class="active">
	<th scope="row" class="text-center">unsafe.Sizeof</th>
	<td rowspan="3" style="vertical-align: middle"><code>uintptr</code></td>
	<td rowspan="3" style="vertical-align: middle">Yes, always.</td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center" style="vertical-align: middle">unsafe.Alignof</th>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center" style="vertical-align: middle">unsafe.Offsetof</th>
	</tr>
	<tr>
	<th scope="row" class="text-center" style="vertical-align: middle">len</th>
	<td rowspan="2" style="vertical-align: middle"><code>int</code></td>
	<td rowspan="2">
		Not always.
		<br/><br/>
		<div class="text-left">
		From <a href="https://golang.org/ref/spec#Length_and_capacity">Go spec</a>:
		<ul>
		<li>
		the expression <code>len(s)</code> is constant if <code>s</code> is a string constant.
		</li>
		<li>
		the expressions <code>len(s)</code> and <code>cap(s)</code> are constants
		if the type of <code>s</code> is an array or pointer to an array
		and the expression <code>s</code> does not contain channel receives or (non-constant) function calls.
		</li>
		</ul>
		</div>
	</td>
	</tr>
	<tr>
	<th scope="row" class="text-center" style="vertical-align: middle">cap</th>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center" style="vertical-align: middle">real</th>
	<td rowspan="2" style="vertical-align: middle"><code>float64</code><br/>(default type)</td>
	<td rowspan="2">
		Not always.
		<br/><br/>
		<div class="text-left">
		From <a href="https://golang.org/ref/spec#Constants">Go spec</a>:
		the expressions <code>real(s)</code> and <code>imag(s)</code> are constants
		if <code>s</code> is a complex constant.
		</div>
	</td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center" style="vertical-align: middle">imag</th>
	</tr>
	<tr>
	<th scope="row" class="text-center" style="vertical-align: middle">complex</th>
	<td style="vertical-align: middle"><code>complex128</code><br/>(default type)</td>
	<td>
		Not always.
		<br/><br/>
		<div class="text-left">
		From <a href="https://golang.org/ref/spec#Constants">Go spec</a>:
		the expression <code>complex(sr, si)</code> is constant
		if both <code>sr</code> and <code>si</code> are numeric constants.
		</div>
	</td>
	</tr>
</tbody>
</table>

<p class="anchor" id="not-addressable"></p>
<h3>
	Addressable and unaddressable values
</h3>

<p>
Please read <a href="unofficial-faq.html#unaddressable-values">this FAQ item</a>
to get which values are addressable or unaddressable.
</p>

<p class="anchor" id="not-comparable"></p>
<h3>
	Types which don't support comparisons
</h3>

<div>
Following types don't support comparisons:
<ul>
<li>map</li>
<li>slice</li>
<li>function</li>
<li>
struct types containing uncomparable fields
</li>
<li>
array types with uncomparable elements
</li>
</ul>
<p>
Types which don't support comparisons can't be used as the key types of map types.
</p>
</div>

<div>
Please note,
<ul>
<li>
although map, slice and function types don't support comparisons,
their values can be compared to the bare <code>nil</code> identifier.
</li>
<li>
comparing two interface values with the same uncomparable dynamic types will panic at run time.
</li>
</ul>

</div>

<p class="anchor" id="declared-but-unused"></p>
<h3>
	Which code elements are allowed to be declared but not used
</h3>

<table class="table table-bordered text-center" style="width: auto !important;">
<thead>
	<tr>
	<th class="text-center"></th>
	<th class="text-center">Allowed To Be Declared But Not Used</th>
	</tr>
</thead>
<tbody>
	<tr class="active">
	<th scope="row" class="text-center">import</th>
	<td>No (for the standard compiler)</td>
	</tr>
	<tr>
	<th scope="row" class="text-center">type</th>
	<td>Yes</td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center">variable</th>
	<td>
		Yes for package-level variables.
		<br/>
		No for local variables (for the standard compiler).
	</td>
	</tr>
	<tr>
	<th scope="row" class="text-center">constant</th>
	<td>Yes</td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center">function</th>
	<td>Yes</td>
	</tr>
	<tr>
	<th scope="row" class="text-center">label</th>
	<td>No (for the standard compiler)</td>
	</tr>
</tbody>
</table>

<p class="anchor" id="groupable-elements"></p>
<h3>
	Named source code elements which declarations can be grouped with <code>()</code>
</h3>

<div>
Following named source code element declarations can be grouped with <code>()</code>:
<ul>
<li>import</li>
<li>type</li>
<li>variable</li>
<li>constant</li>
</ul>
</div>
<p>
Functions and labels can't be grouped with <code>()</code>.
</p>

<p class="anchor" id="declaration-places"></p>
<h3>
	Named source code elements which can be declared both inside functions and outside any functions
</h3>

<div>
Following named source code elements can be declared both inside functions and outside any functions:
<ul>
<li>type</li>
<li>variable</li>
<li>constant</li>
</ul>
</div>
<p>
Imports must be declared before declarations of other elements (and after the package clause).
</p>
<p>
Functions can only be declared outside any functions.
Anonymous functions can be defined inside other function bodies,
but they are not declared.
</p>
<p>
Labels must declared inside functions.
</p>

<p class="anchor" id="additional-return"></p>
<h3>
	Expressions which can return an optional additional bool return value
</h3>

<p>
Following expressions can return an optional additional bool return value:
</p>

<table class="table table-bordered text-center" style="width: auto !important;">
<thead>
	<tr>
	<th class="text-center"></th>
	<th class="text-center">Syntax</th>
	<th class="text-center">Meaning Of The Optional Return</th>
	<th class="text-center">Will Omitting The Optional Return Affect Program Behavior?</th>
	</tr>
</thead>
<tbody>
	<tr class="active">
	<th scope="row" class="text-center" style="vertical-align: middle">map element access</th>
	<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
		e, ok = aMap[key]
	</td>
	<td>whether or not the accessed key is present in the map</td>
	<td>No</td>
	</tr>
	<tr>
	<th scope="row" class="text-center" style="vertical-align: middle">channel value receive</th>
	<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
		e, ok = &lt;- aChannel
	</td>
	<td>whether or not the received value was sent before the channel was closed</td>
	<td>No</td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center" style="vertical-align: middle">type assertion</th>
	<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
		v, ok = anInterface.(T)
	</td>
	<td>whether or not the dynamic type of the interface value matches the asserted type</td>
	<td>Yes<br/>(when the optional bool return is omitted,
		a panic is created if the asserted type is not an ok type)</td>
	</tr>
</tbody>
</table>

<p class="anchor" id="block-forever"></p>
<h3>
	Ways to block current goroutine ‎forever by using the channel mechanism
</h3>

<div>
Following ways can be used to block current goroutine ‎forever:
<ol>
<li>receive from a channel which no values will be sent to
<div>
<pre><code class="language-go"><-make(chan struct{})
// or
<-make(<-chan struct{})
</code></pre></div>
</li>
<li>send value to a channel which no ones will receive values from
<div>
<pre><code class="language-go">make(chan struct{}) <- struct{}{}
// or
make(chan<- struct{}) <- struct{}{}
</code></pre></div>
</li>
<li>receive value from a nil channel
<div>
<pre><code class="language-go"><-chan struct{}(nil)
// or
for range chan struct{}(nil) {}
</code></pre></div>
</li>
<li>send value to a nil channel
<div>
<pre><code class="language-go">chan struct{}(nil) <- struct{}{}
</code></pre></div>
</li>
<li>use a bare select block
<div>
<pre><code class="language-go">select{}
</code></pre></div>
</li>
</ol>
</div>

<p class="anchor" id="concatenate-strings"></p>
<h3>
	Ways to concatenate strings
</h3>

<p>
Please read <a href="string.html#string-concatenation">strings in Go</a> for details.
</p>


<!--

Fatal errors which can be recovered:
* https://play.golang.org/p/bYrfLTzXpc_o bad Mutex.Unlock call
* create goroutine with nil function
* memory allcaotion fails

The optimizations made by gc
* len([]rune(str)) // since Go 1.11
* string ...
  []byte <-> stirng
  len([]rune(string))
  string + string
* since Go 1.11, https://github.com/golang/go/issues/21266#issuecomment-384706868
  possible future append(s, make([]T)) optimiation
  https://docs.google.com/presentation/d/1tpeJZFObkeick4CF-mx0L3CeCgvT15B96aJeRpxEPcE/preview#slide=id.g3bc6fcf60c_0_62
* memclr
* interface copy
* interface dynamic pointer value
* 4 fields struct is much faster than more field struct
  https://docs.google.com/presentation/d/1tpeJZFObkeick4CF-mx0L3CeCgvT15B96aJeRpxEPcE/preview#slide=id.g3bc6fcf60c_0_157
* BCE
  https://docs.google.com/presentation/d/1tpeJZFObkeick4CF-mx0L3CeCgvT15B96aJeRpxEPcE/preview#slide=id.g3bc6fcf60c_0_169


short and standard variable declaration comparison

differences between built-in functions and custom functions.
  * generic
  * built-in function returns can't be omitted
  * builtin-in functions can't be used as values, they have no types.
  * built-in doon't need to be imported before using them, even their identifiers starts with lower..
  * 

built-in function list

	"append":  predeclaredFunction,
	"cap":     predeclaredFunction,
	"close":   predeclaredFunction,
	"complex": predeclaredFunction,
	"copy":    predeclaredFunction,
	"delete":  predeclaredFunction,
	"imag":    predeclaredFunction,
	"len":     predeclaredFunction,
	"make":    predeclaredFunction,
	"new":     predeclaredFunction,
	"panic":   predeclaredFunction,
	"print":   predeclaredFunction,
	"println": predeclaredFunction,
	"real":    predeclaredFunction,
	"recover": predeclaredFunction,


#returns-discardable
return results of calls to which built-in functions can be discarded.

values of which kinds of types can be for-ranged.

ways to return a function: naturally return, return keyword, panic, runtime.Goexit()

the form <code>v[k]</code> can be used to access element of value of which kinds of types?



-->

<!--
todo:
	kinds of control flow blocks
	control flow statements
		return, break, fallthrough, continue, goto
	which control flow statements can be followed a label.
	which control flow statements can appean in which control flow blocks

-->
